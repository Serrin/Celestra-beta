// @ts-nocheck
"use strict";
/** Celestra * @version 6.0.5 esm * @see https://github.com/Serrin/Celestra/ * @license MIT */
/** polyfills **/
(function(global){if(!global.globalThis){if(Object.defineProperty){Object.defineProperty(global,"globalThis",{configurable:true,enumerable:false,value:global,writable:true});}else{global.globalThis=global;}}})(typeof this==="object"?this:Function("return this")());
if(!("sumPrecise" in Math)){Math.sumPrecise=function sumPrecise([...a]){if(a.length===0){return-0;}if(a.every((v)=>typeof v==="number")){let inf=a.indexOf(Infinity)>-1,negInf=a.indexOf(-Infinity)>-1;if(a.some((v)=>v!==v)||(inf&&negInf)){return NaN;}if(inf){return Infinity;}if(negInf){return -Infinity;}let hi=a.filter((v)=>(v===1e20||v===-1e20)).reduce((acc,v)=>acc+v,0);let lo=0.0,c=0.0;for(let item of a.filter((v)=>(v!==1e20&&v!==-1e20))){let y=item-c;let t=lo+y;c=(t-lo)-y;lo=t;}if((lo===0&&hi!==0)||(lo>0&&hi>0)||(lo<0&&hi<0)){return hi;}if((lo>0&&hi<0)||(lo<0&&hi>0)){return lo+hi;}return lo;}throw new TypeError("values passed to Math.sumPrecise must be numbers");};}
if(!("isError" in Error)){Error.isError=function isError(v){let s=Object.prototype.toString.call(v).slice(8,-1).toLowerCase();return(s==="error"||s==="domexception");};}
if(!("groupBy" in Object)){Object.defineProperty(Object,"groupBy",{"configurable":true,"writable":true,"enumerable":true,"value":function(items,callbackFn){"use strict";if(!(typeof callbackFn==="function")){throw new TypeError();}let r=Object.create(null),i=0;for(let item of items){let key=callbackFn(item,i++);if(!(Object.prototype.hasOwnProperty.call(r,key))){r[key]=[];}r[key].push(item);}return r;}});}
if(!("groupBy" in Map)){Object.defineProperty(Map,"groupBy",{"configurable":true,"writable":true,"enumerable":true,"value":function(items,callbackFn){"use strict";if(!(typeof callbackFn==="function")){throw new TypeError();}let r=new Map(),i=0;for(let item of items){let key=callbackFn(item,i++);if(!(r.has(key))){r.set(key,[]);}r.get(key).push(item);}return r;}});}
if(!Array.fromAsync){Array.fromAsync=async function fromAsync(arrayLike,mapfn,thisArg){const isConstructor=(v)=>(typeof v==="function"&&typeof v.prototype==="object");const errorMsg="Input length exceed the Number.MAX_SAFE_INTEGER.";if(Symbol.asyncIterator in arrayLike||Symbol.iterator in arrayLike){let r=isConstructor(this)?new this:Array(0),i=0;for await(const item of arrayLike){if(i>Number.MAX_SAFE_INTEGER){throw TypeError(errorMsg);}else{if(!mapfn){r[i]=item;}else{r[i]=await mapfn.call(thisArg,item,i);}}i++;}r.length=i;return r;}else{let l=arrayLike.length,r=isConstructor(this)?new this(l):Array(l),i=0;while(i<l){if(i>Number.MAX_SAFE_INTEGER){throw TypeError(errorMsg);}let item=await arrayLike[i];if(!mapfn){r[i]=item;}else{r[i]=await mapfn.call(thisArg,item,i);}i++;}r.length=i;return r;}};}
if(("crypto" in globalThis)&&!("randomUUID" in globalThis.crypto)){globalThis.crypto.randomUUID=function randomUUID(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(c)=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16));};}
if(!Object.hasOwn){Object.defineProperty(Object,"hasOwn",{value:function(object,property){if(object==null){throw new TypeError("Cannot convert undefined or null to object");}return Object.prototype.hasOwnProperty.call(Object(object),property);},configurable:true,enumerable:false,writable:true});}
if(!("toReversed" in Array.prototype)){Object.defineProperty(Array.prototype,"toReversed",{"configurable":true,"writable":true,"enumerable":false,"value":function(){"use strict";return this.slice().reverse();}});}
if(!("toSorted" in Array.prototype)){Object.defineProperty(Array.prototype,"toSorted",{"configurable":true,"writable":true,"enumerable":false,"value":function(cFn){"use strict";return this.slice().sort(cFn);}});}
if(!("toSpliced" in Array.prototype)){Object.defineProperty(Array.prototype,"toSpliced",{"configurable":true,"writable":true,"enumerable":false,"value":function(start,deleteCount,...items){let r=this.slice();r.splice(start,deleteCount,...items);return r;}});}
if(!("with" in Array.prototype)){Object.defineProperty(Array.prototype,"with",{"configurable":true,"writable":true,"enumerable":false,"value":function(i,v){"use strict";let r=this.slice();r[i]=v;return r;}});}
if(!("toReversed" in Uint8Array.prototype)){Object.defineProperty(Uint8Array.prototype,"toReversed",{"configurable":true,"writable":true,"enumerable":false,"value":function(){"use strict";return this.slice().reverse();}});}
if(!("toSorted" in Uint8Array.prototype)){Object.defineProperty(Uint8Array.prototype,"toSorted",{"configurable":true,"writable":true,"enumerable":false,"value":function(cFn){"use strict";return this.slice().sort(cFn);}});}
if(!("with" in Uint8Array.prototype)){Object.defineProperty(Uint8Array.prototype,"with",{"configurable":true,"writable":true,"enumerable":false,"value":function(i,v){"use strict";let r=this.slice();r[i]=v;return r;}});}
if(!globalThis.GeneratorFunction){globalThis.GeneratorFunction=Object.getPrototypeOf(function*(){}).constructor;}
if(!globalThis.AsyncFunction){globalThis.AsyncFunction=Object.getPrototypeOf(async function(){}).constructor;}
if(!globalThis.AsyncGeneratorFunction){globalThis.AsyncGeneratorFunction=Object.getPrototypeOf(async function*(){}).constructor;}
/** Core API **/
const BASE16="0123456789ABCDEF";
const BASE32="234567ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const BASE36="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const BASE58="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const BASE62="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
const WORDSAFEALPHABET="23456789CFGHJMPQRVWXcfghjmpqvwx";
function toSafeString(value){const seen=new WeakSet();const replacer=(_key,value)=>{if(typeof value==="function"){return `[Function: ${value.name||"anonymous"}]`;}if(typeof value==="symbol"){return value.toString();}if(value instanceof Date){return `Date(${value.toISOString()})`;}if(value instanceof Error){return `${value.name}: ${value.message}, ${value.stack ?? ""}`;}if(value&&typeof value==="object"){if(seen.has(value)){return "[Circular]" };seen.add(value);}return value;};if(["undefined","null","string","number", "boolean","bigint"].includes(value===null?"null":typeof value)){return String(value);}if(Array.isArray(value)){return `[${value.map(v=>toSafeString(v)).join(", ")}]`;}if(value instanceof Map){return `Map(${value.size}){${Array.from(value.entries()).map(([k,v])=>`${toSafeString(k)}=>${toSafeString(v)}`).join(", ")}}`;}if(value instanceof Set){return `Set(${value.size}){${Array.from(value.values()).map(v=>toSafeString(v)).join(", ")}}`;}try{return JSON.stringify(value,replacer)??String(value);}catch(_e){return String(value);}}
const tap=(fn)=>function(v){fn(v);return v;};
function once(fn){let called=false,res;return function(...a){if(!called){called=true;res=fn(...a);}return res;};}
function curry(fn){const curried=(...args)=>args.length>=fn.length?fn(...args):(...rest)=>curried(...args,...rest);return curried;}
const pipe=(...fns)=>(x)=>fns.reduce((v,f)=>f(v),x);
const compose=(...fns)=>(x)=>fns.reduceRight((v,f)=>f(v),x);
const pick=(O,keys)=>keys.reduce(function(acc,key){if(key in O){acc[key]=O[key];}return acc;},{});
const omit=(O,keys)=>Object.keys(O).reduce(function(acc,key){if(!keys.includes(key)){acc[key]=O[key];}return acc;},{});
const assoc=(O,P,value)=>({...O,[P]:value});
function asyncNoop(){return new Promise(function(resolve){resolve();});}
async function asyncT(){return true;}
async function asyncF(){return false;}
function asyncConstant(value){return async function(){return value;};}
async function asyncIdentity(value){return value;}
function deleteOwnProperty(O,P,Throw=false){if(Object.hasOwn(O,P)){delete O[P];let r=Object.hasOwn(O,P);if(r&&Throw){throw new Error("Celestra.deleteOwnProperty(); error");}return +!r;}return -1;}
function createPolyfillMethod(O,P,value){if(!(Object.hasOwn(O,P))){Object.defineProperty(O,P,{writable:true,enumerable:false,configurable:true,value:value});}return (O[P]===value);}
function createPolyfillProperty(O,P,value){if(!(Object.hasOwn(O,P))){Object.defineProperty(O,P,{writable:true,enumerable:true,configurable:true,value:value});}return (O[P]===value);}
function randomUUIDv7(v4=false){let ts=Date.now().toString(16).padStart(12,"0")+(v4?"4":"7");let uuid=Array.from(([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,(c)=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)));let i=0,p=0;while(i<13){if(p===8||p===13){p++;}uuid[p]=ts[i];p++;i++;}return uuid.join("");}
const delay=(ms)=>new Promise(resolve=>setTimeout(resolve,ms));
const randomBoolean=()=>!Math.round(Math.random());
const getUrlVars=(str=location.search)=>[...new URLSearchParams(str).entries()].reduce(function(o,item){o[item[0]]=item[1];return o;},{});
const obj2string=(value)=>Object.keys(value).reduce((s,p)=>s+=encodeURIComponent(p)+"="+encodeURIComponent(value[p])+"&","").slice(0,-1);
function extend(...args){function _EXT(...args){let targetObject,deep,start;if(typeof args[0]==="boolean"){targetObject=args[1],deep=args[0],start=2;}else{targetObject=args[0],deep=false,start=1;}for(let i=start,length=args.length,sourceObject;i<length;i++){sourceObject=args[i];if(sourceObject!=null){for(let key in sourceObject){if(Object.hasOwn(sourceObject,key)){if(typeof sourceObject[key]==="object"&&deep){targetObject[key]=_EXT(true,{},sourceObject[key]);}else{targetObject[key]=sourceObject[key];}}}}}return targetObject;}return _EXT(...args);}
const sizeIn=(value)=>Object.getOwnPropertyNames(value).length+Object.getOwnPropertySymbols(value).length;
const unBind=(fn)=>Function.prototype.call.bind(fn);
const bind=Function.prototype.call.bind(Function.prototype.bind);
const constant=(value)=>()=>value;
const identity=(value)=>value;
function noop(){}
const T=()=>true;
const F=()=>false;
function nanoid(size=21,alphabet="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-"){let r="",dl=alphabet.length,pos,i=size;while(i--){do{pos=crypto.getRandomValues(new Uint8Array(1))[0];}while(pos>=dl);r+=alphabet[pos];}return r;}
function timestampID(size=21,alphabet="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"){let r=Date.now().toString(36).padStart(10,"0")+"-";let dl=alphabet.length,pos,i=((size>11)?size:12)-11;while(i--){do{pos=crypto.getRandomValues(new Uint8Array(1))[0];}while(pos>=dl);r+=alphabet[pos];}return r;}
/** Assertion API **/
function assertIs(value,expected,message){function _is(value,expected){if(!(["string", "function"].includes(typeof expected))&&!Array.isArray(expected)){throw new TypeError(`[assertIs] TypeError: expectedType must be string, function, or array. Got ${typeof expected}`);}const vType=(value===null?"null":typeof value);let matched=(Array.isArray(expected)?expected:[expected]).some(function (item){if(typeof item==="string"){return vType===item;}if(typeof item==="function"){return value!=null&&value instanceof item;}throw new TypeError(`[assertIs] TypeError: expectedType array elements have to be a string or function. Got ${typeof item}`);});return matched;}if(!_is(value, expected)){if(Error.isError(message)){throw message;}let vName=value.toString?value.toString():Object.prototype.toString.call(value);let eNames=(Array.isArray(expected)?expected:[expected]).map((item)=>(typeof item==="string"?item.toString():item.name??"anonymous")).join(", ");throw new TypeError("[assertIs] Assertion failed: "+vName+" is not a "+eNames+(message?" - "+message:""));}return value;}
function assertIsNot(value,expected,message){function _is(value,expected){if(!(["string", "function"].includes(typeof expected))&&!Array.isArray(expected)){throw new TypeError(`[assertIsNot] TypeError: expectedType must be string, function, or array. Got ${typeof expected}`);}const vType=(value===null?"null":typeof value);let matched=(Array.isArray(expected)?expected:[expected]).some(function (item){if(typeof item==="string"){return vType===item;}if(typeof item==="function"){return value!=null&&value instanceof item;}throw new TypeError(`[assertIsNot] TypeError: expectedType array elements have to be a string or function. Got ${typeof item}`);});return matched;}if(_is(value,expected)){if(Error.isError(message)){throw message;}let vName=value.toString?value.toString():Object.prototype.toString.call(value);let eNames=(Array.isArray(expected)?expected:[expected]).map((item)=>(typeof item==="string"?item.toString():item.name??"anonymous")).join(", ");throw new TypeError("[assertIsNot] Assertion failed: "+vName+" is a "+eNames+(message?" - "+message:""));}return value;}
function assertFail(message){if(Error.isError(message)){throw message;}else{throw new Error("[assertFail] Assertion failed"+(message?": "+message:""));}}
function assertMatch(string,regexp,message){if(typeof string!=="string"){if(Error.isError(message)){throw message;}throw new TypeError("[assertMatch] TypeError: "+string+" is not a string"+(message?" - "+message:""));}if(!(regexp instanceof RegExp)){if(Error.isError(message)){throw message;}throw new TypeError("[assertMatch] TypeError: "+regexp+" is not a RegExp"+(message?" - "+message:""));}if(!(regexp.test(string))){if(Error.isError(message)){throw message;}throw new Error("[assertMatch] Assertion failed"+(message?": "+message:""));}return true;}
function assertDoesNotMatch(string,regexp,message){if(typeof string!=="string"){if(Error.isError(message)){throw message;}throw new TypeError("[assertDoesNotMatch] TypeError: "+string+" is not a string"+(message?" - "+message:""));}if(!(regexp instanceof RegExp)){if(Error.isError(message)){throw message;}throw new TypeError("[assertDoesNotMatch] TypeError: "+regexp+" is not a RegExp"+(message?" - "+message:""));}if(regexp.test(string)){if(Error.isError(message)){throw message;}throw new Error("[assertDoesNotMatch] Assertion failed"+(message?": "+message:""));}return true;}
function assertThrows(callback,message){if(typeof callback!=="function"){throw new TypeError("[assertThrows] TypeError: "+callback+" is not a function"+(message?" - "+message:""));}try{callback();}catch(e){return e;}if(Error.isError(message)){throw message;}throw new Error("[assertThrow] Assertion failed"+(message?": "+message:""));}
function assertIsNotNil(value,message){if(value==null){if(Error.isError(message)){throw message;}throw new TypeError("[assertIsNotNil] Assertion failed: "+value+" is null or undefined"+(message?" - "+message:""));}return value;}
function assertIsNil(value,message){if(value!=null){if(Error.isError(message)){throw message;}throw new TypeError("[assertIsNil] Assertion failed: "+value+" is not null or undefined"+(message?" - "+message:""));}return value;}
function assertTypeOf(value,type,message){const _type=(v)=>((v===null)?"null":(typeof v));if(typeof type!=="string"){if(Error.isError(message)){throw message;}throw new TypeError("[assertTypeOf] TypeError: "+type+" is not a string"+(message?" - "+message:""));}if(_type(value)!==type){if(Error.isError(message)){throw message;}throw new TypeError("[assertTypeOf] Assertion failed: "+value+" is not a "+type+(message?" - "+message:""));}return value;}
function assertNotTypeOf(value,type,message){const _type=(v)=>((v===null)?"null":(typeof v));if(typeof type!=="string"){if(Error.isError(message)){throw message;}throw new TypeError("[assertNotTypeOf] TypeError: "+type+" is not a string"+(message?" - "+message:""));}if(_type(value)===type){if(Error.isError(message)){throw message;}throw new TypeError("[assertNotTypeOf] Assertion failed: "+value+" is not a "+type+(message?" - "+message:""));}return value;}
function assertInstanceOf(value,Class,message){if(typeof Class!=="function"){if(Error.isError(message)){throw message;}throw new TypeError("[assertInstanceOf] TypeError: "+Class+" is not a function"+(message?" - "+message:""));}if(!(value instanceof Class)){if(Error.isError(message)){throw message;}throw new TypeError("[assertInstanceOf] Assertion failed: "+value+" is not a "+((Class.name!=="")?Class.name:Class)+(message?" - "+message:""));}return value;}
function assertNotInstanceOf(value,Class,message){if(typeof Class!=="function"){if(Error.isError(message)){throw message;}throw new TypeError("[assertNotInstanceOf] TypeError: "+Class+" is not a function"+(message?" - "+message:""));}if(value instanceof Class){if(Error.isError(message)){throw message;}throw new TypeError("[assertNotInstanceOf] Assertion failed: "+value+" is not a "+((Class.name!=="")?Class.name:Class)+(message?" - "+message:""));}return value;}
function assert(condition,message){if(!condition){if(Error.isError(message)){throw message;}throw new Error("[assert] Assertion failed"+(message?": "+message:""));}return true;}
function assertTrue(condition,message){if(!condition){if(Error.isError(message)){throw message;}throw new Error("[assertTrue] Assertion failed"+(message?": "+message:""));}return true;}
function assertFalse(condition,message){if(condition){if(Error.isError(message)){throw message;}throw new Error("[assertFalse] Assertion failed"+(message?": "+message:""));}return true;}
function assertEqual(x,y,message){if(!(x==y||(x!==x&&y!==y))){if(Error.isError(message)){throw message;}throw new Error("[assertEqual] Assertion failed"+(message?": "+message:""));}return true;}
function assertStrictEqual(x,y,message){if(!((x===y) ?(x!==0||1/x===1/y):(x!==x&&y!==y))){if(Error.isError(message)){throw message;}throw new Error("[assertStrictEqual] Assertion failed"+(message?": "+message:""));}return true;}
function assertNotEqual(x,y,message){if(x==y||(x!==x&&y!==y)){if(Error.isError(message)){throw message;}throw new Error("[assertNotEqual] Assertion failed"+(message?": "+message:""));}return true;}
function assertNotStrictEqual(x,y,message){if((x===y) ?(x!==0||1/x===1/y):(x!==x&&y!==y)){if(Error.isError(message)){throw message;}throw new Error("[assertNotStrictEqual] Assertion failed"+(message?": "+message:""));}return true;}
function assertDeepEqual(x,y,message){function _isDeepEqual(x,y){const _deepType=(x)=>((x===null)?"null":(x!==x)?"NaN":(typeof x));const _isPrimitive=(v)=>(v==null||(typeof v!=="object"&&typeof v!=="function"));const _isObject=(x)=>(x!=null&&typeof x==="object");const _isSameInstance=(x,y,Class)=>(x instanceof Class)&&(y instanceof Class);const _classof=(x)=>Object.prototype.toString.call(x).slice(8,-1).toLowerCase();const _ownKeys=(x)=>Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));const _isEqual=(x,y)=>(x==y||(x!==x&&y!==y));if(_isEqual(x,y)){return true;}if(_isObject(x)&&_isObject(y)){if(_isEqual(x,y)){return true;}if(_isSameInstance(x,y,WeakMap)||_isSameInstance(x,y,WeakSet)){return _isEqual(x,y);}if(_isSameInstance(x,y,Number)||_isSameInstance(x,y,Boolean)||_isSameInstance(x,y,String)||_isSameInstance(x,y,BigInt)){return _isEqual(x.valueOf(),y.valueOf());}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isDeepEqual(v,y[i]));}if(_isSameInstance(x,y,Int8Array)||_isSameInstance(x,y,Uint8Array)||_isSameInstance(x,y,Uint8ClampedArray)||_isSameInstance(x,y,Int16Array)||_isSameInstance(x,y,Uint16Array)||_isSameInstance(x,y,Int32Array)||_isSameInstance(x,y,Uint32Array)||("Float16Array" in globalThis?_isSameInstance(x,y,Float16Array):false)||_isSameInstance(x,y,Float32Array)||_isSameInstance(x,y,Float64Array)||_isSameInstance(x,y,BigInt64Array)||_isSameInstance(x,y,BigUint64Array)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isEqual(v,y[i]));}if(_isSameInstance(x,y,ArrayBuffer)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}let xTA=new Int8Array(x),yTA=new Int8Array(y);return xTA.every((v,i)=>_isEqual(v,yTA[i]));}if(_isSameInstance(x,y,DataView)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}for(let i=0;i < x.byteLength;i++){if(!_isEqual(x.getUint8(i),y.getUint8(i))){return false;}}return true;}if(_isSameInstance(x,y,Map)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>_isDeepEqual(x.get(v),y.get(v)));}if(_isSameInstance(x,y,Set)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>y.has(v));}if(_isSameInstance(x,y,RegExp)){return _isEqual(x.lastIndex,y.lastIndex)&&_isEqual(x.flags,y.flags)&&_isEqual(x.source,y.source);}if(_isSameInstance(x,y,Error)){return _isDeepEqual( Object.getOwnPropertyNames(x).reduce((acc,k)=>{acc[k]=x[k];return acc;},{}),Object.getOwnPropertyNames(y).reduce((acc,k)=>{acc[k]=y[k];return acc;},{}),);}if(_isSameInstance(x,y,Date)){return _isEqual(+x,+y);}let xKeys=_ownKeys(x),yKeys=_ownKeys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}return xKeys.every((key)=>_isDeepEqual(x[key],y[key]));}return false;}if(!_isDeepEqual(x,y)){if(Error.isError(message)){throw message;}throw new Error("[assertDeepEqual] Assertion failed" +(message?": "+message:""));}return true;}
function assertNotDeepStrictEqual(x,y,message){function _isDeepStrictEqual(x,y){const _deepType=(x)=>((x===null)?"null":(x!==x)?"NaN":(typeof x));const _isPrimitive=(v)=>(v==null||(typeof v!=="object"&&typeof v!=="function"));const _isObject=(x)=>(x!=null&&typeof x==="object");const _isSameInstance=(x,y,Class)=>(x instanceof Class)&&(y instanceof Class);const _classof=(x)=>Object.prototype.toString.call(x).slice(8,-1).toLowerCase();const _ownKeys=(x)=>Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));const _isEqual=(x,y)=>Object.is(x,y);if(_isEqual(x,y)){return true;}if(_isObject(x)&&_isPrimitive(y)&&_classof(x)===typeof y){return _isEqual(x.valueOf(),y);}if(_isPrimitive(x)&&_isObject(y)&&typeof x===_classof(y)){return _isEqual(x,y.valueOf());}if(_deepType(x)!==_deepType(y)){return false;}if(_isObject(x)&&_isObject(y)){if(_isEqual(x,y)){return true;}if(Object.getPrototypeOf(x).constructor!== Object.getPrototypeOf(y).constructor){return false;}if(_isSameInstance(x,y,WeakMap)||_isSameInstance(x,y,WeakSet)){return _isEqual(x,y);}if(_isSameInstance(x,y,Number)||_isSameInstance(x,y,Boolean)||_isSameInstance(x,y,String)||_isSameInstance(x,y,BigInt)){return _isEqual(x.valueOf(),y.valueOf());}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isDeepStrictEqual(v,y[i]));}if(_isSameInstance(x,y,Int8Array)||_isSameInstance(x,y,Uint8Array)||_isSameInstance(x,y,Uint8ClampedArray)||_isSameInstance(x,y,Int16Array)||_isSameInstance(x,y,Uint16Array)||_isSameInstance(x,y,Int32Array)||_isSameInstance(x,y,Uint32Array)||("Float16Array" in globalThis?_isSameInstance(x,y,Float16Array):false)||_isSameInstance(x,y,Float32Array)||_isSameInstance(x,y,Float64Array)||_isSameInstance(x,y,BigInt64Array)||_isSameInstance(x,y,BigUint64Array)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isEqual(v,y[i]));}if(_isSameInstance(x,y,ArrayBuffer)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}let xTA=new Int8Array(x),yTA=new Int8Array(y);return xTA.every((v,i)=>_isEqual(v,yTA[i]));}if(_isSameInstance(x,y,DataView)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}for(let i=0;i < x.byteLength;i++){if(!_isEqual(x.getUint8(i),y.getUint8(i))){return false;}}return true;}if(_isSameInstance(x,y,Map)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>_isDeepStrictEqual(x.get(v),y.get(v)));}if(_isSameInstance(x,y,Set)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>y.has(v));}if(_isSameInstance(x,y,RegExp)){return _isEqual(x.lastIndex,y.lastIndex)&&_isEqual(x.flags,y.flags)&&_isEqual(x.source,y.source);}if(_isSameInstance(x,y,Error)){return _isDeepStrictEqual( Object.getOwnPropertyNames(x).reduce((acc,k)=>{acc[k]=x[k];return acc;},{}),Object.getOwnPropertyNames(y).reduce((acc,k)=>{acc[k]=y[k];return acc;},{}),);}if(_isSameInstance(x,y,Date)){return _isEqual(+x,+y);}let xKeys=_ownKeys(x),yKeys=_ownKeys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}return xKeys.every((key)=>_isDeepStrictEqual(x[key],y[key]));}return false;}if(_isDeepStrictEqual(x,y)){if(Error.isError(message)){throw message;}throw new Error("[assertNotDeepStrictEqual] Assertion failed" +(message?": "+message:""));}return true;}
function assertNotDeepEqual(x,y,message){function _isDeepEqual(x,y){const _deepType=(x)=>((x===null)?"null":(x!==x)?"NaN":(typeof x));const _isPrimitive=(v)=>(v==null||(typeof v!=="object"&&typeof v!=="function"));const _isObject=(x)=>(x!=null&&typeof x==="object");const _isSameInstance=(x,y,Class)=>(x instanceof Class)&&(y instanceof Class);const _classof=(x)=>Object.prototype.toString.call(x).slice(8,-1).toLowerCase();const _ownKeys=(x)=>Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));const _isEqual=(x,y)=>(x==y||(x!==x&&y!==y));if(_isEqual(x,y)){return true;}if(_isObject(x)&&_isObject(y)){if(_isEqual(x,y)){return true;}if(_isSameInstance(x,y,WeakMap)||_isSameInstance(x,y,WeakSet)){return _isEqual(x,y);}if(_isSameInstance(x,y,Number)||_isSameInstance(x,y,Boolean)||_isSameInstance(x,y,String)||_isSameInstance(x,y,BigInt)){return _isEqual(x.valueOf(),y.valueOf());}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isDeepEqual(v,y[i]));}if(_isSameInstance(x,y,Int8Array)||_isSameInstance(x,y,Uint8Array)||_isSameInstance(x,y,Uint8ClampedArray)||_isSameInstance(x,y,Int16Array)||_isSameInstance(x,y,Uint16Array)||_isSameInstance(x,y,Int32Array)||_isSameInstance(x,y,Uint32Array)||("Float16Array" in globalThis?_isSameInstance(x,y,Float16Array):false)||_isSameInstance(x,y,Float32Array)||_isSameInstance(x,y,Float64Array)||_isSameInstance(x,y,BigInt64Array)||_isSameInstance(x,y,BigUint64Array)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isEqual(v,y[i]));}if(_isSameInstance(x,y,ArrayBuffer)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}let xTA=new Int8Array(x),yTA=new Int8Array(y);return xTA.every((v,i)=>_isEqual(v,yTA[i]));}if(_isSameInstance(x,y,DataView)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}for(let i=0;i < x.byteLength;i++){if(!_isEqual(x.getUint8(i),y.getUint8(i))){return false;}}return true;}if(_isSameInstance(x,y,Map)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>_isDeepEqual(x.get(v),y.get(v)));}if(_isSameInstance(x,y,Set)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>y.has(v));}if(_isSameInstance(x,y,RegExp)){return _isEqual(x.lastIndex,y.lastIndex)&&_isEqual(x.flags,y.flags)&&_isEqual(x.source,y.source);}if(_isSameInstance(x,y,Error)){return _isDeepEqual( Object.getOwnPropertyNames(x).reduce((acc,k)=>{acc[k]=x[k];return acc;},{}),Object.getOwnPropertyNames(y).reduce((acc,k)=>{acc[k]=y[k];return acc;},{}),);}if(_isSameInstance(x,y,Date)){return _isEqual(+x,+y);}let xKeys=_ownKeys(x),yKeys=_ownKeys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}return xKeys.every((key)=>_isDeepEqual(x[key],y[key]));}return false;}if(_isDeepEqual(x,y)){if(Error.isError(message)){throw message;}throw new Error("[assertNotDeepEqual] Assertion failed"+(message?": "+message:""));}return true;}
function assertDeepStrictEqual(x,y,message){function _isDeepStrictEqual(x,y){const _deepType=(x)=>((x===null)?"null":(x!==x)?"NaN":(typeof x));const _isPrimitive=(v)=>(v==null||(typeof v!=="object"&&typeof v!=="function"));const _isObject=(x)=>(x!=null&&typeof x==="object");const _isSameInstance=(x,y,Class)=>(x instanceof Class)&&(y instanceof Class);const _classof=(x)=>Object.prototype.toString.call(x).slice(8,-1).toLowerCase();const _ownKeys=(x)=>Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));const _isEqual=(x,y)=>Object.is(x,y);if(_isEqual(x,y)){return true;}if(_isObject(x)&&_isPrimitive(y)&&_classof(x)===typeof y){return _isEqual(x.valueOf(),y);}if(_isPrimitive(x)&&_isObject(y)&&typeof x===_classof(y)){return _isEqual(x,y.valueOf());}if(_deepType(x)!==_deepType(y)){return false;}if(_isObject(x)&&_isObject(y)){if(_isEqual(x,y)){return true;}if(Object.getPrototypeOf(x).constructor!==Object.getPrototypeOf(y).constructor){return false;}if(_isSameInstance(x,y,WeakMap)||_isSameInstance(x,y,WeakSet)){return _isEqual(x,y);}if(_isSameInstance(x,y,Number)||_isSameInstance(x,y,Boolean)||_isSameInstance(x,y,String)||_isSameInstance(x,y,BigInt)){return _isEqual(x.valueOf(),y.valueOf());}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isDeepStrictEqual(v,y[i]));}if(_isSameInstance(x,y,Int8Array)||_isSameInstance(x,y,Uint8Array)||_isSameInstance(x,y,Uint8ClampedArray)||_isSameInstance(x,y,Int16Array)||_isSameInstance(x,y,Uint16Array)||_isSameInstance(x,y,Int32Array)||_isSameInstance(x,y,Uint32Array)||("Float16Array" in globalThis?_isSameInstance(x,y,Float16Array):false)||_isSameInstance(x,y,Float32Array)||_isSameInstance(x,y,Float64Array)||_isSameInstance(x,y,BigInt64Array)||_isSameInstance(x,y,BigUint64Array)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isEqual(v,y[i]));}if(_isSameInstance(x,y,ArrayBuffer)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}let xTA=new Int8Array(x),yTA=new Int8Array(y);return xTA.every((v,i)=>_isEqual(v,yTA[i]));}if(_isSameInstance(x,y,DataView)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}for(let i=0;i < x.byteLength;i++){if(!_isEqual(x.getUint8(i),y.getUint8(i))){return false;}}return true;}if(_isSameInstance(x,y,Map)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>_isDeepStrictEqual(x.get(v),y.get(v)));}if(_isSameInstance(x,y,Set)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>y.has(v));}if(_isSameInstance(x,y,RegExp)){return _isEqual(x.lastIndex,y.lastIndex)&&_isEqual(x.flags,y.flags)&&_isEqual(x.source,y.source);}if(_isSameInstance(x,y,Error)){return _isDeepStrictEqual(Object.getOwnPropertyNames(x).reduce((acc,k)=>{acc[k]=x[k];return acc;},{}),Object.getOwnPropertyNames(y).reduce((acc,k)=>{acc[k]=y[k];return acc;},{}),);}if(_isSameInstance(x,y,Date)){return _isEqual(+x,+y);}let xKeys=_ownKeys(x),yKeys=_ownKeys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}return xKeys.every((key)=>_isDeepStrictEqual(x[key],y[key]));}return false;}if(!_isDeepStrictEqual(x,y)){if(Error.isError(message)){throw message;}throw new Error("[assertDeepStrictEqual] Assertion failed"+(message?": "+message:""));}return true;}
/** String API **/
function b64Encode(s){return btoa(encodeURIComponent(String(s)).replace(/%([0-9A-F]{2})/g,function toSolidBytes(_match, p1){return String.fromCharCode("0x"+p1);}));}
function b64Decode(s){return decodeURIComponent(atob(String(s)).split("").map(function(c){return "%"+("00"+c.charCodeAt(0).toString(16)).slice(-2);}).join(""));}
function strTruncate(str,newLen,omission=""){str=String(str);omission = String(omission);let strUC=Array.from(str);if(newLen>=strUC.length){return str;}return strUC.slice(0,newLen-Array.from(omission).length).join("")+omission;}
const strPropercase=(str)=>String(str).split(" ").map(function(v){let a=Array.from(v).map((c)=>c.toLowerCase());if(a.length){a[0]=a[0].toUpperCase();}return a.join("");}).join(" ");
const strTitlecase=(str)=>String(str).split(" ").map(function(v){let a=Array.from(v).map((c)=>c.toLowerCase());if(a.length){a[0]=a[0].toUpperCase();}return a.join("");}).join(" ");
function strCapitalize(s){let a=[...String(s).toLowerCase()];if(a.length){a[0]=a[0].toUpperCase();}return a.join("");}
function strUpFirst(s){let a=[...String(s)];if(a.length){a[0]=a[0].toUpperCase();}return a.join("");}
function strDownFirst(s){let a=[...String(s)];if(a.length){a[0]=a[0].toLowerCase();}return a.join("");}
const strReverse=(str)=>Array.from(String(str)).reverse().join("");
const strCodePoints=(str)=>Array.from(String(str),(v)=>v.codePointAt(0));
const strFromCodePoints=([...a])=>String.fromCodePoint(...a);
function strAt(s,i,nC){let a=Array.from(String(s));if(nC==null){return a.at(i)||"";}i=i<0?a.length+i:i;if(i>a.length){return a.join("");}a[i]=nC;return a.join("");}
const strSplice=(str,i,c,...add)=>Array.from(str).toSpliced(i,c,add.join("")).join("");
const strHTMLRemoveTags=(str)=>String(str).replace(/<[^>]*>/g," ").replace(/\s{2,}/g," ").trim();
const strHTMLEscape=(str)=>String(str).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;");
const strHTMLUnEscape=(str)=>String(str).replace(/&amp;/g,"&").replace(/&#38;/g,"&").replace(/&lt;/g,"<").replace(/&#60;/g,"<").replace(/&gt;/g,">").replace(/&#62;/g,">").replace(/&quot;/g,'"').replace(/&#34;/g,'"').replace(/&apos;/g,"'").replace(/&#39;/g,"'");
/** DOM API **/
const qsa=(s,c=document)=>Array.from(c.querySelectorAll(s));
const qs=(s,c=document)=>c.querySelector(s);
function domReady(fn){if(document.readyState!=="loading"){fn();}else{document.addEventListener("DOMContentLoaded",function(_event){fn();});}}
function domCreate(t,ps,iH){if(arguments.length===1&& typeof t==="object"){let obj=t;t=obj.elementType;ps={};for(let p in obj){if(p!=="elementType"){ps[p]=obj[p];}}}let el=document.createElement(t);if(ps){for(let p in ps){if(p!=="style"||typeof ps[p]==="string"){el[p]=ps[p];}else{Object.assign(el.style,ps[p]);}}}if(iH){el.innerHTML=iH;}return el;}
function domToElement(s){let e=document.createElement("div");e.innerHTML=s;return e.firstElementChild;}
const domGetCSS=(e,p)=>(p?globalThis.getComputedStyle(e,null)[p]:globalThis.getComputedStyle(e,null));
function domSetCSS(e,n,value){if(typeof n==="string"){e.style[n]=value;}else if(typeof n==="object"){Object.keys(n).forEach((p)=>(e.style[p]=n[p]));}}
function domFadeIn(e,dur,d){let s=e.style,step=25/(dur||500);s.opacity=(s.opacity||0);s.display=(d||"");(function fade(){(s.opacity=parseFloat(s.opacity)+step)>1?s.opacity=1:setTimeout(fade,25);})();}
function domFadeOut(e,dur){let s=e.style,step=25/(dur||500);s.opacity=(s.opacity||1);(function fade(){(s.opacity-=step)<0?s.display="none":setTimeout(fade,25);})();}
function domFadeToggle(e,dur,d=""){if(globalThis.getComputedStyle(e,null).display==="none"){let s=e.style,step=25/(dur||500);s.opacity=(s.opacity||0);s.display=(d||"");(function fade(){(s.opacity=parseFloat(s.opacity)+step)>1?s.opacity=1:setTimeout(fade,25);})();}else{let s=e.style,step=25/(dur||500);s.opacity=(s.opacity||1);(function fade(){(s.opacity-=step)<0?s.display="none":setTimeout(fade,25);})();}}
const domHide=(e)=>e.style.display="none";
const domShow=(e,d="")=>e.style.display=d;
function domToggle(e,d=""){if(globalThis.getComputedStyle(e,null).display==="none"){e.style.display=d;}else{e.style.display="none";}}
const domIsHidden=(e)=>(globalThis.getComputedStyle(e,null).display==="none");
const domSiblings=(el)=>Array.prototype.filter.call(el.parentNode.children,(e)=>(e!==el));
const domSiblingsPrev=(el)=>Array.prototype.slice.call(el.parentNode.children,0,Array.prototype.indexOf.call(el.parentNode.children,el));
const domSiblingsLeft=(el)=>Array.prototype.slice.call(el.parentNode.children,0,Array.prototype.indexOf.call(el.parentNode.children,el));
const domSiblingsNext=(el)=>Array.prototype.slice.call(el.parentNode.children,Array.prototype.indexOf.call(el.parentNode.children,el)+1,el.parentNode.children.length);
const domSiblingsRight=(el)=>Array.prototype.slice.call(el.parentNode.children,Array.prototype.indexOf.call(el.parentNode.children,el)+1,el.parentNode.children.length);
function importScript(...a){for(let item of a){let scr=document.createElement("script");scr.type="text\/javascript";scr.src=item;scr.onerror=function(e){throw new URIError("Loading failed for the script with source "+e.target.src);};(document.head||document.getElementsByTagName("head")[0]).appendChild(scr);}}
function importStyle(...a){for(let item of a){let stl=document.createElement("link");stl.rel="stylesheet";stl.type="text\/css";stl.href=item;stl.onerror=function(e){throw new URIError("Loading failed for the style with source "+e.target.href);};(document.head||document.getElementsByTagName("head")[0]).appendChild(stl);}}
function form2array(f){let fld,a=[];if(typeof f==="object"&&f.nodeName.toLowerCase()==="form"){for(let i=0,len=f.elements.length;i<len;i++){fld=f.elements[i];if(fld.name&&!fld.disabled&&fld.type!=="file"&&fld.type!=="reset"&&fld.type!=="submit"&&fld.type!=="button"){if(fld.type==="select-multiple"){for(let j=0,l=f.elements[i].options.length;j<l;j++){if(fld.options[j].selected){a.push({"name":encodeURIComponent(fld.name),"value":encodeURIComponent(fld.options[j].value)});}}}else if((fld.type!=="checkbox"&&fld.type!=="radio")||fld.checked){a.push({"name": encodeURIComponent(fld.name),"value":encodeURIComponent(fld.value)});}}}}return a;}
function form2string(f){let fld,a=[];if(typeof f==="object"&&f.nodeName.toLowerCase()==="form"){for(let i=0,len=f.elements.length;i<len;i++){fld=f.elements[i];if(fld.name&&!fld.disabled&&fld.type!=="file"&&fld.type!=="reset"&&fld.type!=="submit"&&fld.type!=="button"){if(fld.type==="select-multiple"){for(let j=0,l=f.elements[i].options.length;j<l;j++){if(fld.options[j].selected){a.push(encodeURIComponent(fld.name)+"="+encodeURIComponent(fld.options[j].value));}}}else if((fld.type!=="checkbox"&&fld.type!=="radio")||fld.checked){a.push(encodeURIComponent(fld.name)+"="+encodeURIComponent(fld.value));}}}}return a.join("&").replace(/%20/g,"+");}
const getDoNotTrack=()=>[navigator.doNotTrack,globalThis.doNotTrack,navigator.msDoNotTrack].some((e)=>(e===true||e===1||e==="1"));
function getLocation(s,e){if(!e){e=function(){};}function getE(error){e("ERROR("+error.code+"): "+error.message);}if(navigator.geolocation){navigator.geolocation.getCurrentPosition(s,getE);}else{getE("Geolocation is not supported in this browser.");}}
function createFile(filename,content,dataType){let length=arguments.length;if(length>1){if(length===2){dataType ="text/plain";}let blob=new Blob([content],{type:dataType});let el=globalThis.document.createElement("a");el.href=globalThis.URL.createObjectURL(blob);el.download=filename;document.body.appendChild(el);el.click();document.body.removeChild(el);globalThis.URL.revokeObjectURL(el.href);}else{throw new Error("Celestra createFile error: too few parameters.");}}
const getFullscreen=()=>(document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement||undefined);
function setFullscreenOn(s){let e;if(typeof s==="string"){e=document.querySelector(s); }else if(typeof s==="object"){e=s;}if(e.requestFullscreen){e.requestFullscreen();}else if(e.mozRequestFullScreen){e.mozRequestFullScreen();}else if(e.webkitRequestFullscreen){e.webkitRequestFullscreen();}else if(e.msRequestFullscreen){e.msRequestFullscreen();}}
function setFullscreenOff(){if(document.exitFullscreen){document.exitFullscreen();}else if(document.mozCancelFullScreen){document.mozCancelFullScreen();}else if(document.webkitExitFullscreen){document.webkitExitFullscreen();}else if(document.msExitFullscreen){document.msExitFullscreen();}}
const domGetCSSVar=(n)=>getComputedStyle(document.documentElement).getPropertyValue(n[0]==="-"?n:"--"+n);
const domSetCSSVar=(n,value)=>document.documentElement.style.setProperty((n[0]==="-"?n:"--"+n),value);
const domScrollToTop=()=>globalThis.scrollTo(0,0);
const domScrollToBottom=()=>globalThis.scrollTo(0,document.body.scrollHeight);
const domScrollToElement=(e,top=true)=>e.scrollIntoView(top);
/** AJAX API **/
const domClear=(el)=>Array.from(el.children).forEach((e)=>e.remove());
function getText(url,success){if(typeof url!=="string"){throw new TypeError("Celestra ajax error:The url parameter have to be a string.");}if(typeof success!=="function"){throw new TypeError("Celestra ajax error:The success parameter have to be a function.");}let xhr=new XMLHttpRequest();xhr.onerror=(e)=>console.log("Celestra ajax GET error:"+JSON.stringify(e));xhr.open("GET",url,true);xhr.onreadystatechange=function(){if(this.readyState===4&&this.status===200){success(this.responseText);}};xhr.setRequestHeader("X-Requested-With","XMLHttpRequest");xhr.send();}
function getJson(url,success){if(typeof url!=="string"){throw new TypeError("Celestra ajax error:The url parameter have to be a string.");}if(typeof success!=="function"){throw new TypeError("Celestra ajax error:The success parameter have to be a function.");}let xhr=new XMLHttpRequest();xhr.onerror=(e)=>console.log("Celestra ajax GET error:"+JSON.stringify(e));xhr.open("GET",url,true);xhr.onreadystatechange=function(){if(this.readyState===4&&this.status===200){success(JSON.parse(this.responseText));}};xhr.setRequestHeader("X-Requested-With","XMLHttpRequest");xhr.send();}
function ajax(options){if(typeof options.url!=="string"){throw new TypeError("Celestra ajax error: The url property has to be a string.");}if(typeof options.success!=="function"){throw new TypeError("Celestra ajax error: The success property has to be a function.");}if(options.error===undefined){options.error=(e)=>console.log("Celestra ajax GET error: "+JSON.stringify(e));}if(typeof options.error!=="function"){throw new TypeError("Celestra ajax error: The error property has to be a function or undefined.");}if(!options.queryType){options.queryType="ajax";}else{options.queryType=options.queryType.toLowerCase();}if(!options.type){options.type="get";}else{options.type=options.type.toLowerCase();}let typeStr;if(options.type==="get"){typeStr="GET";}else if(options.type==="post"){typeStr="POST";}else{throw new Error("Celestra ajax error: The type property has to be \"get\" or \"post\"." );}if(!options.format){options.format="text";}else{options.format=options.format.toLowerCase();if(!(["text","json","xml"].includes(options.format))){throw new Error("Celestra ajax error: The format property has to be \"text\" or \"json\" or \"xml\"." );}}let xhr;if(options.queryType==="ajax"){xhr=new XMLHttpRequest();}else if(options.queryType==="cors"){xhr=new XMLHttpRequest();if(!("withCredentials" in xhr)){xhr=new XDomainRequest();}}else{throw new Error("Celestra ajax error: The querytype property has to be \"ajax\" or \"cors\"." );}if(typeof options.user==="string"&&typeof options.password==="string"){xhr.open(typeStr,options.url,true,options.user,options.password);}else{xhr.open(typeStr,options.url,true);}if(options.queryType==="ajax"){xhr.onreadystatechange=function(){if(this.readyState===4&&this.status===200){switch(options.format.toLowerCase()){case "text":options.success(this.responseText);break;case "json":options.success(JSON.parse(this.responseText));break;case"xml":options.success(this.responseXML);break;default:options.success(this.responseText);}}};xhr.setRequestHeader("X-Requested-With","XMLHttpRequest");if(options.typeStr==="POST"){xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");}}else if(options.queryType==="cors"){xhr.onload=function(request){switch(options.format.toLowerCase()){case"text":options.success(request.target.responseText||request.currentTarget.response);break;case "json":options.success(JSON.parse(request.target.responseText||request.currentTarget.response));break;case "xml":options.success(request.target.responseXML||request.currentTarget.responseXML);break;default:options.success(request.target.responseText||request.currentTarget.response);}};}if(typeof options.error==="function"){xhr.onerror=options.error;}if(typeStr==="GET"){xhr.send();}else if(typeStr==="POST"){xhr.send(encodeURI(options.data));}}
/** Type API **/
function is(value,expected,Throw=false){if(!(["string","function","undefined"].includes(typeof expected))&&!Array.isArray(expected)){throw new TypeError(`[is] TypeError: expectedType must be string, function, array or undefined. Got ${typeof expected}`);}if(typeof Throw!=="boolean"){throw new TypeError(`[is] TypeError: Throw has to be a boolean. Got ${typeof Throw}`);}const vType=(value===null?"null":typeof value);if(expected==null){return vType==="object"?Object.getPrototypeOf(value)?.constructor??"object":vType;}let expectedArray=Array.isArray(expected)?expected:[expected];let matched=expectedArray.some(function (item){if(typeof item==="string"){return vType===item;}if(typeof item==="function"){return value!=null&&value instanceof item;}throw new TypeError(`[is] TypeError: expectedType array elements have to be a string or function. Got ${typeof item}`);});if(Throw&&!matched){let vName=value.toString?value:Object.prototype.toString.call(value);let eNames=expectedArray.map((item)=>(typeof item==="string"?item.toString():item.name??"anonymous")).join(", ");throw new TypeError(`[is] TypeError: ${vName} is not a ${eNames}`);}return matched;}
function toObject(value){if(value==null){throw new TypeError("celestra.toObject(); error: "+value);}return (["object","function"].includes(typeof value))?value:Object(value);}
function classof(value,type,Throw=false){let ot=Object.prototype.toString.call(value).slice(8,-1).toLowerCase();if(arguments.length<2){return ot;}if(!Throw){return ot===type.toLowerCase();}if(ot!==type.toLowerCase()){throw TypeError("Celestra classof(); type error: "+ot+" - "+type);}return true;}
function getType(value,type,Throw=false){let ot=Object.prototype.toString.call(value).slice(8,-1).toLowerCase();if(arguments.length<2){return ot;}if(!Throw){return ot===type.toLowerCase();}if(ot!==type.toLowerCase()){throw TypeError("Celestra getType(); type error: "+ot+" - "+type);}return true;}
function toPrimitiveValue(value){if(value==null||typeof value!=="object"){return value;}const ot=Object.prototype.toString.call(value).slice(8,-1);if(["Boolean", "BigInt","Number","String","Symbol"].includes(ot)){return value.valueOf();}return value;}
const isPropertyKey=(value)=>(typeof value==="string"||typeof value==="symbol");
const toPropertyKey=(value)=>(typeof value==="symbol"?value:String(value));
const isIndex=(value)=>(Number.isSafeInteger(value)&&value>=0&&1/value!==1/-0);
const isLength=(value)=>(Number.isSafeInteger(value)&&value>=0&&1/value!==1/-0);
function toIndex(value){value=((value=Math.trunc(+value))!==value||value===0)?0:value;if(value<0||value>(Math.pow(2,53)-1)){throw new RangeError("toIndex(); RangeError: "+value);}return value;}
function toLength(value){value=((value=Math.trunc(+value))!==value||value===0)?0:value;return Math.min(Math.max(value,0),Math.pow(2,53)-1);}
const type=(value)=>((value===null)?"null":(typeof value));
const isSameClass=(x,y)=>(Object.prototype.toString.call(x)===Object.prototype.toString.call(y));
const isSameType=(x,y)=>((x==null||y==null)?(x===y):(typeof x===typeof y));
const isSameInstance=(x,y,Contructor)=>(x instanceof Contructor&&y instanceof Contructor);

function isCoercedObject(value){if(value!=null&&typeof value==="object"){if(value instanceof Number){return Number;}if(value instanceof String){return String;}if(value instanceof Boolean){return Boolean;}if(value instanceof BigInt){return BigInt;}if(typeof value.valueOf?.()==="symbol"){return Symbol;}}return false;}

function isDeepStrictEqual(x,y){const _deepType=(x)=>((x===null)? "null" :(x!==x)? "NaN" :(typeof x));const _isPrimitive=(v)=>(v==null||(typeof v!=="object" &&typeof v!=="function"));const _isObject=(x)=>(x !=null &&typeof x==="object");const _isSameInstance=(x,y,Class)=>(x instanceof Class)&&(y instanceof Class);const _classof=(x)=>Object.prototype.toString.call(x).slice(8,-1).toLowerCase();const _ownKeys=(x)=>Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x));const _isEqual=(x,y)=>Object.is(x,y);if(_isEqual(x,y)){return true;}if(_isObject(x)&&_isPrimitive(y)&&_classof(x)===typeof y){return _isEqual(x.valueOf(),y);}if(_isPrimitive(x)&&_isObject(y)&&typeof x===_classof(y)){return _isEqual(x,y.valueOf());}if(_deepType(x)!==_deepType(y)){return false;}if(_isObject(x)&&_isObject(y)){if(_isEqual(x,y)){return true;}if(Object.getPrototypeOf(x).constructor!==Object.getPrototypeOf(y).constructor){return false;}if(_isSameInstance(x,y,WeakMap)||_isSameInstance(x,y,WeakSet)){return _isEqual(x,y);}if(_isSameInstance(x,y,Number)||_isSameInstance(x,y,Boolean)||_isSameInstance(x,y,String)||_isSameInstance(x,y,BigInt)){return _isEqual(x.valueOf(),y.valueOf());}if(Array.isArray(x)&&Array.isArray(y)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>isDeepStrictEqual(v,y[i]));}if(_isSameInstance(x,y,Int8Array)||_isSameInstance(x,y,Uint8Array)||_isSameInstance(x,y,Uint8ClampedArray)||_isSameInstance(x,y,Int16Array)||_isSameInstance(x,y,Uint16Array)||_isSameInstance(x,y,Int32Array)||_isSameInstance(x,y,Uint32Array)||("Float16Array" in globalThis ? _isSameInstance(x,y,Float16Array): false)||_isSameInstance(x,y,Float32Array)||_isSameInstance(x,y,Float64Array)||_isSameInstance(x,y,BigInt64Array)||_isSameInstance(x,y,BigUint64Array)){if(x.length!==y.length){return false;}if(x.length===0){return true;}return x.every((v,i)=>_isEqual(v,y[i]));}if(_isSameInstance(x,y,ArrayBuffer)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}let xTA=new Int8Array(x),yTA=new Int8Array(y);return xTA.every((v,i)=>_isEqual(v,yTA[i]));}if(_isSameInstance(x,y,DataView)){if(x.byteLength!==y.byteLength){return false;}if(x.byteLength===0){return true;}for(let i=0;i<x.byteLength;i++){if(!_isEqual(x.getUint8(i),y.getUint8(i))){return false;}}return true;}if(_isSameInstance(x,y,Map)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>isDeepStrictEqual(x.get(v),y.get(v)));}if(_isSameInstance(x,y,Set)){if(x.size!==y.size){return false;}if(x.size===0){return true;}return [...x.keys()].every((v)=>y.has(v));}if(_isSameInstance(x,y,RegExp)){return _isEqual(x.lastIndex,y.lastIndex)&&_isEqual(x.flags,y.flags)&&_isEqual(x.source,y.source);}if(_isSameInstance(x,y,Error)){return isDeepStrictEqual(Object.getOwnPropertyNames(x).reduce((acc,k)=>{acc[k]=x[k];return acc;},{}),Object.getOwnPropertyNames(y).reduce((acc,k)=>{acc[k]=y[k];return acc;},{}),);}if(_isSameInstance(x,y,Date)){return _isEqual(+x,+y);}let xKeys=_ownKeys(x),yKeys=_ownKeys(y);if(xKeys.length!==yKeys.length){return false;}if(xKeys.length===0){return true;}return xKeys.every((key)=>isDeepStrictEqual(x[key],y[key]));}return false;}
function isEmptyValue(value){function _isTypedArray(value){const constructors=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array, Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array];if("Float16Array" in globalThis){constructors.push(globalThis.Float16Array);}return constructors.some((Class)=>value instanceof Class);}if(value==null||Number.isNaN(value)){return true;}if(Array.isArray(value)||_isTypedArray(value)||typeof value==="string"||value instanceof String){return value.length===0;}if(value instanceof Map||value instanceof Set){return value.size===0;}if(value instanceof ArrayBuffer||value instanceof DataView){return value.byteLength===0;}if(typeof value[Symbol.iterator]==="function"){const it=value[Symbol.iterator]();return it.next().done;}if("Iterator" in globalThis?(value instanceof Iterator):(value!=null&&typeof value==="object"&&typeof value.next==="function")){try{for(const _ of value){return false;}return true;}catch{}}if(isObject(value)){const keys=[...Object.getOwnPropertyNames(value),...Object.getOwnPropertySymbols(value)];if(keys.length===0)return true;if(keys.length===1&&keys[0]==="length"&&value.length===0){return true;}}return false;}
const isProxy=(value)=>Boolean(value!=null&&value.__isProxy);
const isAsyncGeneratorFn=(value)=>(Object.getPrototypeOf(value).constructor===Object.getPrototypeOf(async function*(){}).constructor);
const isClass=(value)=>(typeof value==="function"&&typeof value.prototype==="object");
const isPlainObject=(value)=>(value!=null&&typeof value==="object"&&(Object.getPrototypeOf(value)===Object.prototype||Object.getPrototypeOf(value)===null));
const isChar=(value)=>(typeof value==="string"&&(value.length===1||Array.from(value).length===1));
const isNumeric=(value)=>(((typeof value==="number"||typeof value==="bigint")&& value===value)?true:(!isNaN(parseFloat(value)))&&isFinite(value));
const isObject=(value)=>(value!=null&&(typeof value==="object"||typeof value==="function"));
const isFunction=(value)=>(typeof value==="function"||Object.prototype.toString.call(value)==="[object Function]");
const isCallable=(value)=>((value!=null&&["object","function"].includes(typeof value))?(typeof value.call==="function"):false);
const isArraylike=(value)=>value!=null&&typeof value!=="function"&&(typeof value==="object"||typeof value==="string")&&Number.isSafeInteger(value.length)&&value.length>=0;
const isNull=(value)=>(value===null);
const isUndefined=(value)=>(value===undefined);
const isNil=(value)=>(value==null);
const isPrimitive=(value)=>(value==null||(typeof value!=="object"&&typeof value!=="function"));
const isIterator=(value)=>("Iterator" in globalThis ?(value instanceof Iterator):(value!=null&&typeof value==="object"&&typeof value.next==="function"));
const isRegexp=(value)=>(value instanceof RegExp);
const isElement=(value)=>(value!=null&&typeof value==="object"&&value.nodeType===1);
const isIterable=(value)=>(value!=null&&typeof value[Symbol.iterator]==="function");
const isAsyncIterable=(value)=>(value!=null&&typeof value[Symbol.asyncIterator]==="function");
function isTypedArray(value){const constructors=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array];if("Float16Array" in globalThis){constructors.push(globalThis.Float16Array);}return constructors.some((Class)=>value instanceof Class);}
const isGeneratorFn=(value)=>(Object.getPrototypeOf(value).constructor===Object.getPrototypeOf(function*(){}).constructor);
const isAsyncFn=(value)=>(Object.getPrototypeOf(value).constructor===Object.getPrototypeOf(async function(){}).constructor);
/** Cookie API **/
function setCookie(name,value,hours=8760,path="/",domain,secure,SameSite="Lax",HttpOnly){if(typeof name==="object"){let settings=name;name=settings.name;value=settings.value;hours=settings.hours||8760;path=settings.path||"/";domain=settings.domain;secure=settings.secure;SameSite=settings.SameSite||"Lax";HttpOnly=settings.HttpOnly;}let expire=new Date();expire.setTime(expire.getTime()+(Math.round(hours*60*60*1000)));document.cookie=encodeURIComponent(name)+"="+encodeURIComponent(value)+"; expires="+expire.toUTCString()+"; path="+path+(domain?"; domain="+domain:"")+(secure?"; secure":"")+(typeof SameSite==="string"&&SameSite.length?"; SameSite="+SameSite:"")+(HttpOnly?"; HttpOnly":"")+";";}
function getCookie(name){if(document.cookie.length!==0){let r={},a=document.cookie.split(";");for(let i=0,l=a.length;i<l;i++){let e=a[i].trim().split("=");r[decodeURIComponent(e[0])]=decodeURIComponent(e[1]);}return (name?(r[name]?r[name]:null):r);}return (name?null:{});}
const hasCookie=(n)=>(document.cookie.includes(encodeURIComponent(n)+"="));
function removeCookie(name,path="/",domain,secure,SameSite="Lax",HttpOnly){if(typeof name==="object"){let settings=name;name=settings.name;path=settings.path||"/";domain=settings.domain;secure=settings.secure;SameSite=settings.SameSite||"Lax";HttpOnly=settings.HttpOnly;}let r=(document.cookie.includes(encodeURIComponent(name)+"="));document.cookie=encodeURIComponent(name)+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT"+"; path="+path+(domain?"; domain="+domain:"")+(secure?"; secure":"")+(typeof SameSite==="string"&&SameSite.length?"; SameSite="+SameSite:"")+(HttpOnly?"; HttpOnly":"")+";";return r;}
function clearCookies(path="/",domain,secure,SameSite="Lax",HttpOnly){if(typeof path==="object"){let settings=path;path=settings.path||"/";domain=settings.domain;secure=settings.secure;SameSite=settings.SameSite||"Lax";HttpOnly=settings.HttpOnly;}if(document.cookie.length!==0){let a=document.cookie.split(";");for(let i=0,l=a.length;i<l;i++){document.cookie=encodeURIComponent(a[i].trim().split("=")[0])+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT"+"; path="+path+(domain?"; domain="+domain:"")+(secure?"; secure":"")+(typeof SameSite==="string"&&SameSite.length?"; SameSite="+SameSite:"")+(HttpOnly?"; HttpOnly":"")+";";}}}
/** Collections API **/
function castArray(...args){if(!args.length){return [];}const value=args[0];return Array.isArray(value)?value:[value];}
const compact=(iter)=>Array.from(iter).filter((value)=>value||value===0);
function unique(iter,resolver){if(resolver==null){return [...new Set(iter)];}if(typeof resolver==="string"){return Array.from(iter).reduce(function(acc,el){if(acc.every((e)=>e[resolver]!==el[resolver])){acc.push(el);}return acc;},[]);}if(typeof resolver==="function"){let cache=new Map();for(let item of iter){let key=resolver(item);if(!cache.has(key)){cache.set(key,item);}}return [...cache.values()];}}
function count(iter,fn){let i=0,r=0;for(let item of iter){if(fn(item,i++)){r++;}}return r;}
function arrayDeepClone([...a]){const _ADC=(v)=>(Array.isArray(v)?Array.from(v,_ADC):v);return _ADC(a);}
const initial=([...a])=>a.slice(0,-1);
function shuffle([...a]){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
const partition=([...a],fn)=>[a.filter(fn),a.filter((e,i,a)=>!(fn(e,i,a)))];
const setUnion=(...a)=>new Set(a.map(([...e])=>e).flat());
const setIntersection=([...a],b)=>new Set(a.filter((v)=>b.has(v)));
const setDifference=([...a],b)=>new Set(a.filter((v)=>!(b.has(v))));
const setSymmetricDifference=(a,b)=>new Set([...a].filter((v)=>!(b.has(v))).concat([...b].filter((v)=>!(a.has(v)))));
const isSuperset=([...sup],[...sub])=>sub.every((v)=>sup.includes(v));
const min=(...a)=>a.reduce((acc,v)=>(v<acc?v:acc),a[0]);
const max=(...a)=>a.reduce((acc,v)=>(v>acc?v:acc),a[0]);
const arrayRepeat=(value,n=100)=>Array(n).fill(value);
const arrayCycle=([...a],n=100)=>Array(n).fill(a).flat();
const arrayRange=(s=0,e=99,st=1)=>Array.from({length:(e-s)/st+1},(_v,i)=>s+(i*st));
function zip(...a){a=a.map((v)=>Array.from(v));return Array.from({length: Math.min(...a.map(v=>v.length))}).map((_,i)=>a.map(v=>v[i]));}
const unzip=([...a])=>a.map((v)=>Array.from(v)).reduce((acc,v)=>{v.forEach((item,i)=>{if(!Array.isArray(acc[i])){acc[i]=[];} acc[i].push(item);});return acc;},[]);
function zipObj([...a1],[...a2]){let r={},l=Math.min(a1.length,a2.length);for(let i=0;i<l;i++){r[a1[i]]=a2[i];}return r;}
const arrayAdd=(a,v)=>(!a.includes(v))?!!a.push(v):false;
function arrayClear(a){a.length=0;return a;}
function arrayRemove(a,value,all=false){let found=a.indexOf(value)>-1;if(!all){let pos=a.indexOf(value);if(pos>-1){a.splice(pos,1);}}else{let pos=-1;while((pos=a.indexOf(value))>-1){a.splice(pos,1);}}return found;}
function arrayRemoveBy(a,fn,all=false){let found=a.findIndex(fn)>-1;if(!all){let pos=a.findIndex(fn);if(pos>-1){a.splice(pos,1);}}else{let pos=-1;while((pos=a.findIndex(fn))>-1){a.splice(pos,1)}}return found;}
function arrayMerge(t,...a){t.push(...[].concat(...a));return t;}
function*iterRange(s=0,st=1,e=Infinity){let i=s;while(i<=e){yield i;i+=st;}}
function*iterCycle([...a],n=Infinity){let i=0;while(i<n){yield* a;i++;}}
function*iterRepeat(value,n=Infinity){let i=0;while(i<n){yield value;i++;}}
function*takeWhile(iter,fn){for(let item of iter){if(!fn(item)){break;}yield item;}}
function*dropWhile(iter,fn){let d=true;for(let item of iter){if(d&&!fn(item)){d=false;}if(!d){yield item;}}}
function*take(iter,n=1){let i=n;for(let item of iter){if(i<=0){break;}yield item;i--;}}
function*drop(iter,n=1){let i=n;for(let item of iter){if(i<1){yield item;}else{i--;}}}
function forEach(iter,fn){let i=0;for(let item of iter){fn(item,i++);}}
function forEachRight([...a],fn){let i=a.length;while(i--){fn(a[i],i);}}
function*map(iter,fn){let i=0;for(let item of iter){yield fn(item,i++);}}
function*filter(iter,fn){let i=0;for(let item of iter){if(fn(item,i++)){yield item;}}}
function*reject(iter,fn){let i=0;for(let item of iter){if(!fn(item,i++)){yield item;}}}
function*slice(iter,begin=0,end=Infinity){let i=0;for(let item of iter){if(i>=begin&&i<=end){yield item;}else if(i>end){return;}i++;}}
function*tail(iter){let first=true;for(let item of iter){if(!first){yield item;}else{first=false;}}}
function item(iter,p){let i=0;for(let item of iter){if(i++===p){return item;}}}
function nth(iter,p){let i=0;for(let item of iter){if(i++===p){return item;}}}
function size(iter){let i=0;for(let _item of iter){i++;}return i;}
function first(iter){for(let item of iter){return item;}}
function head(iter){for(let item of iter){return item;}}
const last=([...a])=>a[a.length-1];
function*reverse([...a]){let i=a.length;while(i--){yield a[i];}}
const sort=([...a],ns)=>a.sort(ns?(x,y)=>x-y:undefined);
function includes(collection,value,comparator){if(comparator!==undefined&&typeof comparator!=="function"){throw new TypeError(`[includes] TypeError:comparator is not a function or undefined. Got ${typeof comparator}`);}const _isIterator=(v)=>v!=null&&typeof v==="object" && typeof v.next==="function";const _isIterable=(v)=>(v!=null && typeof v[Symbol.iterator]==="function");const _isEqual=comparator||((x,y)=>x===y||(x!==x&&y!==y));const cType=(collection===null?"null":typeof collection);if(collection==null||!(["object","function","string"].includes(cType))||collection instanceof WeakMap||collection instanceof WeakSet){return false;}if(typeof collection==="string"||collection instanceof String){return collection.includes(String(value));}if(collection instanceof Map){for(const item of collection.keys()){if(_isEqual(item,value)){return true;}}for(const item of collection.values()){if(_isEqual(item,value)){return true;}}return false;}if(_isIterator(collection)||_isIterable(collection)){for(const item of collection){if(_isEqual(item,value)){return true;}}return false;}if(["object","function"].includes(cType)){for(const item of Object.keys(collection)){if(_isEqual(item,value)){return true;}}for(const item of Object.values(collection)){if(_isEqual(item,value)){return true;}}for(const item of Object.getOwnPropertySymbols(collection)){if(_isEqual(item,value)){return true;}}return false;}return false;}
function contains(iter,v){for(let item of iter){if(item===v||(item!==item&&v!==v)){return true;}}return false;}
function find(iter,fn){let i=0;for(let item of iter){if(fn(item,i++)){return item;}}}
function findLast(iter,fn){let i=0,r;for(let item of iter){if(fn(item,i++)){r=item;}}return r;}
function every(iter,fn){let i=0;for(let item of iter){if(!fn(item,i++)){return false;}}if(i===0){return false;}return true;}
function some(iter,fn){let i=0;for(let item of iter){if(fn(item,i++)){return true;}}return false;}
function none(iter,fn){let i=0;for(let item of iter){if(fn(item,i++)){return false;}}if(i===0){return false;}return true;}
const takeRight=([...a],n=1)=>a.reverse().slice(0,n);
function*takeRightWhile([...a],fn){let i=0;for(let item of a.reverse()){if(fn(item,i++)){yield item;}else{break;}}}
const dropRight=([...a],n=1)=>a.reverse().slice(n);
function* dropRightWhile([...a],fn){let d=true,i=0;for(let item of a.reverse()){if(d&&!fn(item,i++)){d=false;}if(!d){yield item;}}}
function*concat(){for(let item of arguments){if(typeof item[Symbol.iterator]==="function"||("Iterator" in globalThis?(item instanceof Iterator):(typeof item==="object"&&typeof item.next==="function"))){yield* item;}else{yield item;}}}
function reduce(iter,fn,iv){let acc=iv,i=0;for(let item of iter){if(i===0&&acc===undefined){acc=item;}else{acc=fn(acc,item,i++);}}return acc;}
function*enumerate(iter,offset=0){let i=offset;for(let item of iter){yield [i++,item];}}
function*flat(iter){for(let item of iter){if(typeof item[Symbol.iterator]==="function"||("Iterator" in globalThis ? (item instanceof Iterator):(typeof item==="object"&&typeof item.next==="function"))){yield* item;}else{yield item;}}}
function join(iter,separator=","){separator=String(separator);let r="";for(let item of iter){r+=separator+item;}return r.slice(separator.length);}
const withOut=([...a],[...fl])=>a.filter((e)=>!fl.includes(e));
/** Math API **/
const isFloat=(value)=>(typeof value==="number"&&value===value&&!!(value%1));
function toInteger(value){value=((value=Math.trunc(+value))!==value||value===0)?0:value;return Math.min(Math.max(value,-(Math.pow(2,53)-1)),Math.pow(2,53)-1);}
const toIntegerOrInfinity=(value)=>((value=Math.trunc(+value))!==value||value===0)?0:value;
const sum=(...a)=>(a.every((value)=>typeof value==="number")?Math.sumPrecise(a):a.slice(1).reduce((acc,v)=>acc+v,a[0]));
const avg=(...a)=>Math.sumPrecise(a)/a.length;
const product=(f,...a)=>a.reduce((acc,v)=>acc*v,f);
function clamp(value,min=-9007199254740991,max=9007199254740991){function _normalize(v){if(typeof v!=="bigint"&&typeof v!=="number"){v=Number(v);}if(v===-Infinity){return -9007199254740991;}if(v===Infinity){return 9007199254740991;}if(v===0){return 0;}return v;}value=_normalize(value);min=_normalize(min);max=_normalize(max);if(value!==value){return value;}if(min!==min||max!==max){throw new RangeError("clamp();RangeError: minimum and maximum should not to be NaN");}if(min>max){throw new RangeError("clamp();RangeError: minimum should be lower than maximum");}return (value<min)?min:((value>max)?max:value);}
function minmax(value,min=-9007199254740991,max=9007199254740991){function _normalize(v){if(typeof v!=="bigint"&&typeof v!=="number"){v=Number(v);}if(v===-Infinity){return -9007199254740991;}if(v===Infinity){return 9007199254740991;}if(v===0){return 0;}return v;}value=_normalize(value);min=_normalize(min);max=_normalize(max);if(value!==value){return value;}if(min!==min||max!==max){throw new RangeError("clamp();RangeError: minimum and maximum should not to be NaN");}if(min>max){throw new RangeError("clamp();RangeError: minimum should be lower than maximum");}return (value<min)?min:((value>max)?max:value);}
function isEven(value){let r=value%2;if(r===r){return r===0;}return false;}
function isOdd(value){let r=value%2;if(r===r){return r!==0;}return false;}
const toInt8=(value)=>((value=Math.min(Math.max(-128,Math.trunc(Number(value))),127))===value)?value:0;
const toUInt8=(value)=>((value=Math.min(Math.max(0,Math.trunc(Number(value))),255))===value)?value:0;
const toInt16=(value)=>((value=Math.min(Math.max(-32768,Math.trunc(Number(value))),32767))===value)?value:0;
const toUInt16=(value)=>((value=Math.min(Math.max(0,Math.trunc(Number(value))),65535))===value)?value:0;
const toInt32=(value)=>((value=Math.min(Math.max(-2147483648,Math.trunc(Number(value))),2147483647))===value)?value:0;
const toUInt32=(value)=>((value=Math.min(Math.max(0,Math.trunc(Number(value))),4294967295))===value)?value:0;
const toBigInt64=(value)=>BigInt(typeof value==="bigint"?(value>Math.pow(2,63)-1?Math.pow(2,63)-1:value<Math.pow(-2,63)?Math.pow(-2,63):value):((value=Math.min(Math.max(Math.pow(-2,63),Math.trunc(Number(value))),Math.pow(2,63)-1))===value)?value:0);
const toBigUInt64=(value)=>BigInt(typeof value==="bigint"?(value>Math.pow(2,64)-1?Math.pow(2,64)-1:value<0?0:value):((value=Math.min(Math.max(0,Math.trunc(Number(value))),Math.pow(2,64)-1))===value)?value:0);
const toFloat32=(value)=>((value=Math.min(Math.max(-3.4e38,Number(value)),3.4e38))===value)?value:0;
const isInt8=(value)=>(Number.isInteger(value)?(value>=-128&&value<=127):false);
const isUInt8=(value)=>(Number.isInteger(value)?(value>=0&&value<=255):false);
const isInt16=(value)=>(Number.isInteger(value)?(value>=-32768&&value<=32767):false);
const isUInt16=(value)=>(Number.isInteger(value)?(value>=0&&value<=65535):false);
const isInt32=(value)=>(Number.isInteger(value)?(value>=-2147483648&&value<=2147483647):false);
const isUInt32=(value)=>(Number.isInteger(value)?(value>=0&&value<=4294967295):false);
const isBigInt64=(value)=>(typeof value==="bigint"?(value>=Math.pow(-2,63)&&value<=Math.pow(2,63)-1):false);
const isBigUInt64=(value)=>(typeof value==="bigint"?(value>=0&&value<=Math.pow(2,64)-1):false);
const toFloat16=(value)=>((value=Math.min(Math.max(-65504,Number(value)),65504))===value)?value:0;
const isFloat16=(value)=>((typeof value==="number"&&value===value)?(value>=-65504&&value<=65504):false);
const signbit=(value)=>(((value=Number(value))!==value)?false:((value<0)||Object.is(value,-0)));
function randomInt(min=100,max){if(max==null){max=min;min=0;}min=Math.ceil(Number(min));return Math.floor(Math.random()*(Math.floor(Number(max))-min+1)+min);}
function randomFloat(min=100,max){if(max==null){max=min;min=0;}let r=(Math.random()*(max-min+1))+min;return r>max?max:r;}
const inRange=(value,min,max)=>(value>=min&&value<=max);
/** object header **/
const VERSION="Celestra v6.0.5 esm";
function noConflict(){return celestra;}
const celestra={/** object header **/ VERSION, noConflict, /** Core API **/ BASE16, BASE32, BASE36, BASE58, BASE62, WORDSAFEALPHABET, toSafeString, tap, once, curry, pipe, compose, pick, omit, assoc, asyncNoop, asyncT, asyncF, asyncConstant, asyncIdentity, deleteOwnProperty, createPolyfillMethod, createPolyfillProperty, randomUUIDv7, delay, randomBoolean, getUrlVars, obj2string, extend, sizeIn, unBind, bind, constant, identity, noop, T, F, nanoid, timestampID, /** Assertion API **/ assertIs, assertIsNot, assertFail, assertMatch, assertDoesNotMatch, assertThrows, assertIsNotNil, assertIsNil, assertTypeOf, assertNotTypeOf, assertInstanceOf, assertNotInstanceOf, assert, assertTrue, assertFalse, assertEqual, assertStrictEqual, assertNotEqual, assertNotStrictEqual, assertDeepEqual, assertNotDeepStrictEqual, assertNotDeepEqual, assertDeepStrictEqual, /** String API **/ b64Encode, b64Decode, strTruncate, strPropercase, strTitlecase, strCapitalize, strUpFirst, strDownFirst, strReverse, strCodePoints, strFromCodePoints, strAt, strSplice, strHTMLRemoveTags, strHTMLEscape, strHTMLUnEscape, /** DOM API **/ qsa, qs, domReady, domCreate, domToElement, domGetCSS, domSetCSS, domFadeIn, domFadeOut, domFadeToggle, domHide, domShow, domToggle, domIsHidden, domSiblings, domSiblingsPrev, domSiblingsLeft, domSiblingsNext, domSiblingsRight, importScript, importStyle, form2array, form2string, getDoNotTrack, getLocation, createFile, getFullscreen, setFullscreenOn, setFullscreenOff, domGetCSSVar, domSetCSSVar, domScrollToTop, domScrollToBottom, domScrollToElement, domClear, /** AJAX API **/ getText, getJson, ajax, /** Type API **/ is, toObject, classof, getType, toPrimitiveValue, isPropertyKey, toPropertyKey, isIndex, isLength, toIndex, toLength, type, isSameClass, isSameType, isSameInstance, isCoercedObject, isDeepStrictEqual, isEmptyValue, isProxy, isAsyncGeneratorFn, isClass, isPlainObject, isChar, isNumeric, isObject, isFunction, isCallable, isArraylike, isNull, isUndefined, isNil, isPrimitive, isIterator, isRegexp, isElement, isIterable, isAsyncIterable, isTypedArray, isGeneratorFn, isAsyncFn, /** Cookie API **/ setCookie, getCookie, hasCookie, removeCookie, clearCookies, /** Collections API **/ castArray, compact, unique, count, arrayDeepClone, initial, shuffle, partition, setUnion, setIntersection, setDifference, setSymmetricDifference, isSuperset, min, max, arrayRepeat, arrayCycle, arrayRange, zip, unzip, zipObj, arrayAdd, arrayClear, arrayRemove, arrayRemoveBy, arrayMerge, iterRange, iterCycle, iterRepeat, takeWhile, dropWhile, take, drop, forEach, forEachRight, map, filter, reject, slice, tail, item, nth, size, first, head, last, reverse, sort, includes, contains, find, findLast, every, some, none, takeRight, takeRightWhile, dropRight, dropRightWhile, concat, reduce, enumerate, flat, join, withOut, /** Math API **/ isFloat, toInteger, toIntegerOrInfinity, sum, avg, product, clamp, minmax, isEven, isOdd, toInt8, toUInt8, toInt16, toUInt16, toInt32, toUInt32, toBigInt64, toBigUInt64, toFloat32, isInt8, isUInt8, isInt16, isUInt16, isInt32, isUInt32, isBigInt64, isBigUInt64, toFloat16, isFloat16, signbit, randomInt, randomFloat, inRange};
/* ESM */
export default celestra;
export{/** object header **/ VERSION, noConflict, /** Core API **/ BASE16, BASE32, BASE36, BASE58, BASE62, WORDSAFEALPHABET, toSafeString, tap, once, curry, pipe, compose, pick, omit, assoc, asyncNoop, asyncT, asyncF, asyncConstant, asyncIdentity, deleteOwnProperty, createPolyfillMethod, createPolyfillProperty, randomUUIDv7, delay, randomBoolean, getUrlVars, obj2string, extend, sizeIn, unBind, bind, constant, identity, noop, T, F, nanoid, timestampID, /** Assertion API **/ assertIs, assertIsNot, assertFail, assertMatch, assertDoesNotMatch, assertThrows, assertIsNotNil, assertIsNil, assertTypeOf, assertNotTypeOf, assertInstanceOf, assertNotInstanceOf, assert, assertTrue, assertFalse, assertEqual, assertStrictEqual, assertNotEqual, assertNotStrictEqual, assertDeepEqual, assertNotDeepStrictEqual, assertNotDeepEqual, assertDeepStrictEqual, /** String API **/ b64Encode, b64Decode, strTruncate, strPropercase, strTitlecase, strCapitalize, strUpFirst, strDownFirst, strReverse, strCodePoints, strFromCodePoints, strAt, strSplice, strHTMLRemoveTags, strHTMLEscape, strHTMLUnEscape, /** DOM API **/ qsa, qs, domReady, domCreate, domToElement, domGetCSS, domSetCSS, domFadeIn, domFadeOut, domFadeToggle, domHide, domShow, domToggle, domIsHidden, domSiblings, domSiblingsPrev, domSiblingsLeft, domSiblingsNext, domSiblingsRight, importScript, importStyle, form2array, form2string, getDoNotTrack, getLocation, createFile, getFullscreen, setFullscreenOn, setFullscreenOff, domGetCSSVar, domSetCSSVar, domScrollToTop, domScrollToBottom, domScrollToElement, domClear, /** AJAX API **/ getText, getJson, ajax, /** Type API **/ is, toObject, classof, getType, toPrimitiveValue, isPropertyKey, toPropertyKey, isIndex, isLength, toIndex, toLength, type, isSameClass, isSameType, isSameInstance, isCoercedObject, isDeepStrictEqual, isEmptyValue, isProxy, isAsyncGeneratorFn, isClass, isPlainObject, isChar, isNumeric, isObject, isFunction, isCallable, isArraylike, isNull, isUndefined, isNil, isPrimitive, isIterator, isRegexp, isElement, isIterable, isAsyncIterable, isTypedArray, isGeneratorFn, isAsyncFn, /** Cookie API **/ setCookie, getCookie, hasCookie, removeCookie, clearCookies, /** Collections API **/ castArray, compact, unique, count, arrayDeepClone, initial, shuffle, partition, setUnion, setIntersection, setDifference, setSymmetricDifference, isSuperset, min, max, arrayRepeat, arrayCycle, arrayRange, zip, unzip, zipObj, arrayAdd, arrayClear, arrayRemove, arrayRemoveBy, arrayMerge, iterRange, iterCycle, iterRepeat, takeWhile, dropWhile, take, drop, forEach, forEachRight, map, filter, reject, slice, tail, item, nth, size, first, head, last, reverse, sort, includes, contains, find, findLast, every, some, none, takeRight, takeRightWhile, dropRight, dropRightWhile, concat, reduce, enumerate, flat, join, withOut, /** Math API **/ isFloat, toInteger, toIntegerOrInfinity, sum, avg, product, clamp, minmax, isEven, isOdd, toInt8, toUInt8, toInt16, toUInt16, toInt32, toUInt32, toBigInt64, toBigUInt64, toFloat32, isInt8, isUInt8, isInt16, isUInt16, isInt32, isUInt32, isBigInt64, isBigUInt64, toFloat16, isFloat16, signbit, randomInt, randomFloat, inRange};