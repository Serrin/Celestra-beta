declare const VERSION = "Celestra v6.1.0 node";
type ArrayLike = {
    length: number;
    [n: number]: any;
};
type IterableAndIterator = Iterable<any> | Iterator<any> | IterableIterator<any>;
type IterableAndIteratorAndArrayLike = Iterable<any> | Iterator<any> | IterableIterator<any> | ArrayLike;
type IteratorReturn = Iterable<any> | IteratorResult<any> | Generator<number, void, unknown>;
declare const BASE16 = "0123456789ABCDEF";
declare const BASE32 = "234567ABCDEFGHIJKLMNOPQRSTUVWXYZ";
declare const BASE36 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
declare const BASE58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
declare const BASE62 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
declare const WORDSAFEALPHABET = "23456789CFGHJMPQRVWXcfghjmpqvwx";
declare function toSafeString(value: unknown): string;
declare const tap: (fn: Function) => any;
declare function once(fn: Function): Function;
declare function curry(fn: Function): Function;
declare const pipe: (...functions: Function[]) => Function;
declare const compose: (...functions: Function[]) => Function;
declare const pick: (obj: object, keys: string[]) => object;
declare const omit: (obj: object, keys: string[]) => object;
declare const assoc: (obj: object, property: string, value: unknown) => object;
declare function asyncNoop(): Promise<void>;
declare function asyncT(): Promise<boolean>;
declare function asyncF(): Promise<boolean>;
declare function asyncConstant(value: unknown): Function;
declare function asyncIdentity(value: unknown): Promise<any>;
declare function deleteOwnProperty(obj: Object, property: string, Throw?: boolean): number;
declare function createPolyfillMethod(obj: Object, property: string, value: Function): boolean;
declare function createPolyfillProperty(obj: object, property: string, value: unknown): boolean;
declare function randomUUIDv7(v4?: boolean): string;
declare const delay: (milisec: number) => Promise<void>;
declare const randomBoolean: () => boolean;
declare const getUrlVars: (str?: string) => Object;
declare const obj2string: (obj: object) => string;
declare function extend(...args: Array<object | boolean>): object;
declare const sizeIn: (obj: object) => number;
declare const unBind: (fn: Function) => Function;
declare const bind: (thisArg: any, ...argArray: any[]) => any;
declare const constant: (value: unknown) => Function;
declare const identity: (value: unknown) => any;
declare function noop(): void;
declare const T: () => boolean;
declare const F: () => boolean;
declare function nanoid(size?: number, alphabet?: string): string;
declare function timestampID(size?: number, alphabet?: string): string;
declare function assertIs(value: any, expected: string | Function | Array<string | Function> | undefined, message?: any): any;
declare function assertIsNot(value: any, expected: string | Function | Array<string | Function> | undefined, message?: any): any;
declare function assertFail(message?: any): void;
declare function assertMatch(string: string, regexp: RegExp, message?: any): boolean;
declare function assertDoesNotMatch(string: string, regexp: RegExp, message?: any): boolean;
declare function assertThrows(callback: Function, message?: any): any;
declare function assertIsNotNullish(value: unknown, message?: any): {};
declare function assertIsNullish(value: unknown, message?: any): any;
declare function assert(condition: any, message?: any): boolean;
declare function assertTrue(condition: any, message?: any): boolean;
declare function assertFalse(condition: any, message?: any): boolean;
declare function assertEqual(x: any, y: any, message?: any): boolean;
declare function assertStrictEqual(x: any, y: any, message?: any): boolean;
declare function assertNotEqual(x: any, y: any, message?: any): boolean;
declare function assertNotStrictEqual(x: any, y: any, message?: any): boolean;
declare function assertDeepEqual(x: any, y: any, message?: any): boolean;
declare function assertNotDeepStrictEqual(x: any, y: any, message?: any): boolean;
declare function assertNotDeepEqual(x: any, y: any, message?: any): boolean;
declare function assertDeepStrictEqual(x: any, y: any, message?: any): boolean;
declare function b64Encode(str: any): string;
declare function b64Decode(str: any): string;
declare function strTruncate(str: any, newLength: number, omission?: string): string;
declare const strPropercase: (str: any) => string;
declare const strTitlecase: (str: any) => string;
declare function strCapitalize(str: any): string;
declare function strUpFirst(str: any): string;
declare function strDownFirst(str: any): string;
declare const strReverse: (str: any) => string;
declare const strCodePoints: (str: any) => any[];
declare const strFromCodePoints: ([...array]: Iterable<any, void, undefined>) => string;
declare function strAt(str: string, index: number, newChar?: string): string;
declare const strSplice: (str: string, index: number, count: number, ...add: any[]) => string;
declare const strHTMLRemoveTags: (str: any) => string;
declare const strHTMLEscape: (str: any) => string;
declare const strHTMLUnEscape: (str: string) => string;
declare function is(value: any, expected?: string | Function | Array<string | Function> | undefined, Throw?: boolean): string | Function | boolean;
declare function toObject(value: unknown): Object | symbol | Function;
declare function toPrimitiveValue(value: unknown): any;
declare const isPropertyKey: (value: unknown) => boolean;
declare const toPropertyKey: (value: unknown) => string | symbol;
declare const isIndex: (value: unknown) => boolean;
declare const isLength: (value: unknown) => boolean;
declare function toIndex(value: any): number;
declare function toLength(value: any): number;
type TypeOfTag = "null" | "undefined" | "number" | "bigint" | "boolean" | "string" | "symbol" | "object" | "function";
declare const typeOf: (value: unknown) => TypeOfTag;
declare const isSameType: (x: any, y: any) => boolean;
declare const isSameInstance: (x: any, y: any, Contructor: Function) => boolean;
declare function isCoercedObject(value: unknown): Function | boolean;
declare function isDeepStrictEqual(x: any, y: any): boolean;
declare function isEmptyValue(value: any): boolean;
declare const isProxy: (value: any) => boolean;
declare const isAsyncGeneratorFn: (value: unknown) => boolean;
declare const isClass: (value: unknown) => boolean;
declare const isPlainObject: (value: unknown) => boolean;
declare const isChar: (value: unknown) => boolean;
declare const isNumeric: (value: any) => boolean;
declare const isObject: (value: unknown) => value is object;
declare const isFunction: (value: unknown) => value is Function;
declare const isCallable: (value: any) => boolean;
declare function isArraylike(value: unknown): value is ArrayLike;
declare const isNull: (value: unknown) => value is null;
declare const isUndefined: (value: unknown) => value is undefined;
type Nullish = undefined | null;
declare const isNullish: (value: unknown) => value is Nullish;
type Primitive = null | undefined | number | bigint | boolean | string | symbol;
declare const isPrimitive: (value: unknown) => value is Primitive;
declare const isIterator: (value: any) => boolean;
declare const isRegexp: (value: unknown) => value is RegExp;
declare const isElement: (value: any) => boolean;
declare const isIterable: (value: any) => boolean;
declare const isAsyncIterable: (value: unknown) => boolean;
type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array | (typeof globalThis extends {
    Float16Array: infer F;
} ? F : never);
declare function isTypedArray(value: unknown): value is TypedArray;
declare const isGeneratorFn: (value: unknown) => boolean;
declare const isAsyncFn: (value: unknown) => boolean;
declare function castArray<T>(...args: [T] | []): T[];
declare const compact: (iter: IterableAndIteratorAndArrayLike) => any[];
declare function unique(iter: IterableAndIterator, resolver?: string | Function | null | undefined): any[] | void;
declare function count(iter: IterableAndIterator, fn: Function): number;
declare function arrayDeepClone([...array]: Iterable<any, void, undefined>): any[];
declare const initial: ([...array]: Iterable<any, void, undefined>) => any[];
declare function shuffle([...array]: Iterable<any, void, undefined>): any[];
declare const partition: ([...array]: Iterable<any, void, undefined>, fn: Function) => any[];
declare const setUnion: (...args: any[]) => Set<any>;
declare const setIntersection: ([...array]: Iterable<any, void, undefined>, b: Set<any>) => Set<any>;
declare const setDifference: ([...array]: Iterable<any, void, undefined>, b: Set<any>) => Set<any>;
declare const setSymmetricDifference: (array: Set<any>, b: Set<any>) => Set<any>;
declare const isSuperset: ([...superSet]: Iterable<any, void, undefined>, [...subSet]: Iterable<any, void, undefined>) => boolean;
declare const min: (...args: any[]) => any;
declare const max: (...args: any[]) => any;
declare const arrayRepeat: (value: unknown, n?: number) => any[];
declare const arrayCycle: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
declare const arrayRange: (start?: number, end?: number, step?: number) => any[];
declare function zip(...args: any[]): any[];
declare const unzip: ([...array]: Iterable<any, void, undefined>) => any[];
declare function zipObj([...array1]: Iterable<any, void, undefined>, [...array2]: Iterable<any, void, undefined>): {
    [key: string]: any;
};
declare const arrayAdd: (array: any[], value: unknown) => boolean;
declare function arrayClear(array: any[]): any[];
declare function arrayRemove(array: any[], value: unknown, all?: boolean): boolean;
declare function arrayRemoveBy(array: any[], fn: Function, all?: boolean): boolean;
declare function arrayMerge(target: any[], ...sources: any[]): any[];
declare function iterRange(start?: number, step?: number, end?: number): Generator<number, void, unknown>;
declare function iterCycle([...array]: Iterable<any, void, undefined>, n?: number): IteratorReturn;
declare function iterRepeat(value: unknown, n?: number): IteratorReturn;
declare function takeWhile(iter: IterableAndIterator, fn: Function): IteratorReturn;
declare function dropWhile(iter: IterableAndIterator, fn: Function): IteratorReturn;
declare function take(iter: IterableAndIterator, n?: number): IteratorReturn;
declare function drop(iter: IterableAndIterator, n?: number): IteratorReturn;
declare function forEach(iter: IterableAndIterator, fn: Function): void;
declare function forEachRight([...array]: Iterable<any, void, undefined>, fn: Function): void;
declare function map(iter: IterableAndIterator, fn: Function): IteratorReturn;
declare function filter(iter: IterableAndIterator, fn: Function): IteratorReturn;
declare function reject(iter: IterableAndIterator, fn: Function): IteratorReturn;
declare function slice(iter: IterableAndIterator, begin?: number, end?: number): IteratorReturn;
declare function tail(iter: IterableAndIterator): IteratorReturn;
declare function item(iter: IterableAndIterator, pos: number): any;
declare function nth(iter: IterableAndIterator, pos: number): any;
declare function size(iter: IterableAndIterator): number;
declare function first(iter: IterableAndIterator): any;
declare function head(iter: IterableAndIterator): any;
declare const last: ([...array]: Iterable<any, void, undefined>) => any;
declare function reverse([...array]: Iterable<any, void, undefined>): IteratorReturn;
declare const sort: ([...array]: Iterable<any, void, undefined>, numbers?: boolean) => any[];
declare function includes(collection: any, value: unknown, comparator?: Function): boolean;
declare function find(iter: IterableAndIterator, fn: Function): any;
declare function findLast(iter: IterableAndIterator, fn: Function): any;
declare function every(iter: IterableAndIterator, fn: Function): boolean;
declare function some(iter: IterableAndIterator, fn: Function): boolean;
declare function none(iter: IterableAndIterator, fn: Function): boolean;
declare const takeRight: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
declare function takeRightWhile([...array]: Iterable<any, void, undefined>, fn: Function): IteratorReturn;
declare const dropRight: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
declare function dropRightWhile([...array]: Iterable<any, void, undefined>, fn: Function): IteratorReturn;
declare function concat(...args: any[]): IteratorReturn;
declare function reduce(iter: IterableAndIterator, fn: Function, initialvalue?: any): any;
declare function enumerate(iter: IterableAndIterator, offset?: number): IteratorReturn;
declare function flat(iter: IterableAndIterator): IteratorReturn;
declare function join(iter: IterableAndIterator, separator?: string): string;
declare const withOut: ([...array]: Iterable<any, void, undefined>, [...filterValues]: Iterable<any, void, undefined>) => any[];
declare const isFloat: (value: unknown) => boolean;
declare function toInteger(value: any): number;
declare const toIntegerOrInfinity: (value: unknown) => number;
declare const sum: (...args: any[]) => any;
declare const avg: (...args: number[]) => number;
declare const product: (first: number, ...args: number[]) => number;
declare function clamp(value: any, min?: number | bigint, max?: number | bigint): number | bigint;
declare function minmax(value: any, min?: number | bigint, max?: number | bigint): number | bigint;
declare function isEven(value: number): boolean;
declare function isOdd(value: number): boolean;
declare const toInt8: (value: unknown) => number;
declare const toUInt8: (value: unknown) => number;
declare const toInt16: (value: unknown) => number;
declare const toUInt16: (value: unknown) => number;
declare const toInt32: (value: unknown) => number;
declare const toUInt32: (value: unknown) => number;
declare const toBigInt64: (value: any | bigint) => bigint;
declare const toBigUInt64: (value: unknown) => bigint;
declare const toFloat32: (value: unknown) => number;
declare const isInt8: (value: unknown | number) => boolean;
declare const isUInt8: (value: unknown | number) => boolean;
declare const isInt16: (value: unknown) => boolean;
declare const isUInt16: (value: unknown) => boolean;
declare const isInt32: (value: unknown) => boolean;
declare const isUInt32: (value: unknown | number) => boolean;
declare const isBigInt64: (value: unknown) => boolean;
declare const isBigUInt64: (value: unknown | number | bigint) => boolean;
declare const toFloat16: (value: unknown) => number;
declare const isFloat16: (value: unknown | number | bigint) => boolean;
declare const signbit: (value: unknown | number | bigint) => boolean;
declare function randomInt(min?: number | undefined, max?: number | null | undefined): number;
declare function randomFloat(min?: number | undefined, max?: number | null | undefined): number;
declare const inRange: (value: number, min: number, max: number) => boolean;
declare const _default: {
    VERSION: string;
    BASE16: string;
    BASE32: string;
    BASE36: string;
    BASE58: string;
    BASE62: string;
    WORDSAFEALPHABET: string;
    toSafeString: typeof toSafeString;
    tap: (fn: Function) => any;
    once: typeof once;
    curry: typeof curry;
    pipe: (...functions: Function[]) => Function;
    compose: (...functions: Function[]) => Function;
    pick: (obj: object, keys: string[]) => object;
    omit: (obj: object, keys: string[]) => object;
    assoc: (obj: object, property: string, value: unknown) => object;
    asyncNoop: typeof asyncNoop;
    asyncT: typeof asyncT;
    asyncF: typeof asyncF;
    asyncConstant: typeof asyncConstant;
    asyncIdentity: typeof asyncIdentity;
    deleteOwnProperty: typeof deleteOwnProperty;
    createPolyfillMethod: typeof createPolyfillMethod;
    createPolyfillProperty: typeof createPolyfillProperty;
    randomUUIDv7: typeof randomUUIDv7;
    delay: (milisec: number) => Promise<void>;
    randomBoolean: () => boolean;
    getUrlVars: (str?: string) => Object;
    obj2string: (obj: object) => string;
    extend: typeof extend;
    sizeIn: (obj: object) => number;
    unBind: (fn: Function) => Function;
    bind: (thisArg: any, ...argArray: any[]) => any;
    constant: (value: unknown) => Function;
    identity: (value: unknown) => any;
    noop: typeof noop;
    T: () => boolean;
    F: () => boolean;
    nanoid: typeof nanoid;
    timestampID: typeof timestampID;
    assertIs: typeof assertIs;
    assertIsNot: typeof assertIsNot;
    assertFail: typeof assertFail;
    assertMatch: typeof assertMatch;
    assertDoesNotMatch: typeof assertDoesNotMatch;
    assertThrows: typeof assertThrows;
    assertIsNotNullish: typeof assertIsNotNullish;
    assertIsNullish: typeof assertIsNullish;
    assert: typeof assert;
    assertTrue: typeof assertTrue;
    assertFalse: typeof assertFalse;
    assertEqual: typeof assertEqual;
    assertStrictEqual: typeof assertStrictEqual;
    assertNotEqual: typeof assertNotEqual;
    assertNotStrictEqual: typeof assertNotStrictEqual;
    assertDeepEqual: typeof assertDeepEqual;
    assertNotDeepStrictEqual: typeof assertNotDeepStrictEqual;
    assertNotDeepEqual: typeof assertNotDeepEqual;
    assertDeepStrictEqual: typeof assertDeepStrictEqual;
    b64Encode: typeof b64Encode;
    b64Decode: typeof b64Decode;
    strTruncate: typeof strTruncate;
    strPropercase: (str: any) => string;
    strTitlecase: (str: any) => string;
    strCapitalize: typeof strCapitalize;
    strUpFirst: typeof strUpFirst;
    strDownFirst: typeof strDownFirst;
    strReverse: (str: any) => string;
    strCodePoints: (str: any) => any[];
    strFromCodePoints: ([...array]: Iterable<any, void, undefined>) => string;
    strAt: typeof strAt;
    strSplice: (str: string, index: number, count: number, ...add: any[]) => string;
    strHTMLRemoveTags: (str: any) => string;
    strHTMLEscape: (str: any) => string;
    strHTMLUnEscape: (str: string) => string;
    is: typeof is;
    toObject: typeof toObject;
    toPrimitiveValue: typeof toPrimitiveValue;
    isPropertyKey: (value: unknown) => boolean;
    toPropertyKey: (value: unknown) => string | symbol;
    isIndex: (value: unknown) => boolean;
    isLength: (value: unknown) => boolean;
    toIndex: typeof toIndex;
    toLength: typeof toLength;
    typeOf: (value: unknown) => TypeOfTag;
    isSameType: (x: any, y: any) => boolean;
    isSameInstance: (x: any, y: any, Contructor: Function) => boolean;
    isCoercedObject: typeof isCoercedObject;
    isDeepStrictEqual: typeof isDeepStrictEqual;
    isEmptyValue: typeof isEmptyValue;
    isProxy: (value: any) => boolean;
    isAsyncGeneratorFn: (value: unknown) => boolean;
    isClass: (value: unknown) => boolean;
    isPlainObject: (value: unknown) => boolean;
    isChar: (value: unknown) => boolean;
    isNumeric: (value: any) => boolean;
    isObject: (value: unknown) => value is object;
    isFunction: (value: unknown) => value is Function;
    isCallable: (value: any) => boolean;
    isArraylike: typeof isArraylike;
    isNull: (value: unknown) => value is null;
    isUndefined: (value: unknown) => value is undefined;
    isNullish: (value: unknown) => value is Nullish;
    isPrimitive: (value: unknown) => value is Primitive;
    isIterator: (value: any) => boolean;
    isRegexp: (value: unknown) => value is RegExp;
    isElement: (value: any) => boolean;
    isIterable: (value: any) => boolean;
    isAsyncIterable: (value: unknown) => boolean;
    isTypedArray: typeof isTypedArray;
    isGeneratorFn: (value: unknown) => boolean;
    isAsyncFn: (value: unknown) => boolean;
    castArray: typeof castArray;
    compact: (iter: IterableAndIteratorAndArrayLike) => any[];
    unique: typeof unique;
    count: typeof count;
    arrayDeepClone: typeof arrayDeepClone;
    initial: ([...array]: Iterable<any, void, undefined>) => any[];
    shuffle: typeof shuffle;
    partition: ([...array]: Iterable<any, void, undefined>, fn: Function) => any[];
    setUnion: (...args: any[]) => Set<any>;
    setIntersection: ([...array]: Iterable<any, void, undefined>, b: Set<any>) => Set<any>;
    setDifference: ([...array]: Iterable<any, void, undefined>, b: Set<any>) => Set<any>;
    setSymmetricDifference: (array: Set<any>, b: Set<any>) => Set<any>;
    isSuperset: ([...superSet]: Iterable<any, void, undefined>, [...subSet]: Iterable<any, void, undefined>) => boolean;
    min: (...args: any[]) => any;
    max: (...args: any[]) => any;
    arrayRepeat: (value: unknown, n?: number) => any[];
    arrayCycle: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
    arrayRange: (start?: number, end?: number, step?: number) => any[];
    zip: typeof zip;
    unzip: ([...array]: Iterable<any, void, undefined>) => any[];
    zipObj: typeof zipObj;
    arrayAdd: (array: any[], value: unknown) => boolean;
    arrayClear: typeof arrayClear;
    arrayRemove: typeof arrayRemove;
    arrayRemoveBy: typeof arrayRemoveBy;
    arrayMerge: typeof arrayMerge;
    iterRange: typeof iterRange;
    iterCycle: typeof iterCycle;
    iterRepeat: typeof iterRepeat;
    takeWhile: typeof takeWhile;
    dropWhile: typeof dropWhile;
    take: typeof take;
    drop: typeof drop;
    forEach: typeof forEach;
    forEachRight: typeof forEachRight;
    map: typeof map;
    filter: typeof filter;
    reject: typeof reject;
    slice: typeof slice;
    tail: typeof tail;
    item: typeof item;
    nth: typeof nth;
    size: typeof size;
    first: typeof first;
    head: typeof head;
    last: ([...array]: Iterable<any, void, undefined>) => any;
    reverse: typeof reverse;
    sort: ([...array]: Iterable<any, void, undefined>, numbers?: boolean) => any[];
    includes: typeof includes;
    find: typeof find;
    findLast: typeof findLast;
    every: typeof every;
    some: typeof some;
    none: typeof none;
    takeRight: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
    takeRightWhile: typeof takeRightWhile;
    dropRight: ([...array]: Iterable<any, void, undefined>, n?: number) => any[];
    dropRightWhile: typeof dropRightWhile;
    concat: typeof concat;
    reduce: typeof reduce;
    enumerate: typeof enumerate;
    flat: typeof flat;
    join: typeof join;
    withOut: ([...array]: Iterable<any, void, undefined>, [...filterValues]: Iterable<any, void, undefined>) => any[];
    isFloat: (value: unknown) => boolean;
    toInteger: typeof toInteger;
    toIntegerOrInfinity: (value: unknown) => number;
    sum: (...args: any[]) => any;
    avg: (...args: number[]) => number;
    product: (first: number, ...args: number[]) => number;
    clamp: typeof clamp;
    minmax: typeof minmax;
    isEven: typeof isEven;
    isOdd: typeof isOdd;
    toInt8: (value: unknown) => number;
    toUInt8: (value: unknown) => number;
    toInt16: (value: unknown) => number;
    toUInt16: (value: unknown) => number;
    toInt32: (value: unknown) => number;
    toUInt32: (value: unknown) => number;
    toBigInt64: (value: any | bigint) => bigint;
    toBigUInt64: (value: unknown) => bigint;
    toFloat32: (value: unknown) => number;
    isInt8: (value: unknown | number) => boolean;
    isUInt8: (value: unknown | number) => boolean;
    isInt16: (value: unknown) => boolean;
    isUInt16: (value: unknown) => boolean;
    isInt32: (value: unknown) => boolean;
    isUInt32: (value: unknown | number) => boolean;
    isBigInt64: (value: unknown) => boolean;
    isBigUInt64: (value: unknown | number | bigint) => boolean;
    toFloat16: (value: unknown) => number;
    isFloat16: (value: unknown | number | bigint) => boolean;
    signbit: (value: unknown | number | bigint) => boolean;
    randomInt: typeof randomInt;
    randomFloat: typeof randomFloat;
    inRange: (value: number, min: number, max: number) => boolean;
};
export default _default;
export { VERSION, BASE16, BASE32, BASE36, BASE58, BASE62, WORDSAFEALPHABET, toSafeString, tap, once, curry, pipe, compose, pick, omit, assoc, asyncNoop, asyncT, asyncF, asyncConstant, asyncIdentity, deleteOwnProperty, createPolyfillMethod, createPolyfillProperty, randomUUIDv7, delay, randomBoolean, getUrlVars, obj2string, extend, sizeIn, unBind, bind, constant, identity, noop, T, F, nanoid, timestampID, assertIs, assertIsNot, assertFail, assertMatch, assertDoesNotMatch, assertThrows, assertIsNotNullish, assertIsNullish, assert, assertTrue, assertFalse, assertEqual, assertStrictEqual, assertNotEqual, assertNotStrictEqual, assertDeepEqual, assertNotDeepStrictEqual, assertNotDeepEqual, assertDeepStrictEqual, b64Encode, b64Decode, strTruncate, strPropercase, strTitlecase, strCapitalize, strUpFirst, strDownFirst, strReverse, strCodePoints, strFromCodePoints, strAt, strSplice, strHTMLRemoveTags, strHTMLEscape, strHTMLUnEscape, is, toObject, toPrimitiveValue, isPropertyKey, toPropertyKey, isIndex, isLength, toIndex, toLength, typeOf, isSameType, isSameInstance, isCoercedObject, isDeepStrictEqual, isEmptyValue, isProxy, isAsyncGeneratorFn, isClass, isPlainObject, isChar, isNumeric, isObject, isFunction, isCallable, isArraylike, isNull, isUndefined, isNullish, isPrimitive, isIterator, isRegexp, isElement, isIterable, isAsyncIterable, isTypedArray, isGeneratorFn, isAsyncFn, castArray, compact, unique, count, arrayDeepClone, initial, shuffle, partition, setUnion, setIntersection, setDifference, setSymmetricDifference, isSuperset, min, max, arrayRepeat, arrayCycle, arrayRange, zip, unzip, zipObj, arrayAdd, arrayClear, arrayRemove, arrayRemoveBy, arrayMerge, iterRange, iterCycle, iterRepeat, takeWhile, dropWhile, take, drop, forEach, forEachRight, map, filter, reject, slice, tail, item, nth, size, first, head, last, reverse, sort, includes, find, findLast, every, some, none, takeRight, takeRightWhile, dropRight, dropRightWhile, concat, reduce, enumerate, flat, join, withOut, isFloat, toInteger, toIntegerOrInfinity, sum, avg, product, clamp, minmax, isEven, isOdd, toInt8, toUInt8, toInt16, toUInt16, toInt32, toUInt32, toBigInt64, toBigUInt64, toFloat32, isInt8, isUInt8, isInt16, isUInt16, isInt32, isUInt32, isBigInt64, isBigUInt64, toFloat16, isFloat16, signbit, randomInt, randomFloat, inRange };
//# sourceMappingURL=celestra.node.d.mts.map